{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/alessioricci/projects/udemy/udemy-app/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RouterResponseController = void 0;\n\nconst common_1 = require(\"@nestjs/common\");\n\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst sse_stream_1 = require(\"./sse-stream\");\n\nclass RouterResponseController {\n  constructor(applicationRef) {\n    this.applicationRef = applicationRef;\n  }\n\n  apply(result, response, httpStatusCode) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return _this.applicationRef.reply(response, result, httpStatusCode);\n    })();\n  }\n\n  redirect(resultOrDeferred, response, redirectResponse) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const result = yield _this2.transformToResult(resultOrDeferred);\n      const statusCode = result && result.statusCode ? result.statusCode : redirectResponse.statusCode ? redirectResponse.statusCode : common_1.HttpStatus.FOUND;\n      const url = result && result.url ? result.url : redirectResponse.url;\n\n      _this2.applicationRef.redirect(response, statusCode, url);\n    })();\n  }\n\n  render(resultOrDeferred, response, template) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const result = yield _this3.transformToResult(resultOrDeferred);\n      return _this3.applicationRef.render(response, template, result);\n    })();\n  }\n\n  transformToResult(resultOrDeferred) {\n    return _asyncToGenerator(function* () {\n      if (resultOrDeferred && shared_utils_1.isFunction(resultOrDeferred.subscribe)) {\n        return resultOrDeferred.toPromise();\n      }\n\n      return resultOrDeferred;\n    })();\n  }\n\n  getStatusByMethod(requestMethod) {\n    switch (requestMethod) {\n      case common_1.RequestMethod.POST:\n        return common_1.HttpStatus.CREATED;\n\n      default:\n        return common_1.HttpStatus.OK;\n    }\n  }\n\n  setHeaders(response, headers) {\n    headers.forEach(({\n      name,\n      value\n    }) => this.applicationRef.setHeader(response, name, value));\n  }\n\n  setStatus(response, statusCode) {\n    this.applicationRef.status(response, statusCode);\n  }\n\n  sse(result, response, request) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      _this4.assertObservable(result);\n\n      const stream = new sse_stream_1.SseStream(request);\n      stream.pipe(response);\n      const subscription = result.pipe(operators_1.debounce(message => new Promise(resolve => {\n        if (!shared_utils_1.isObject(message)) {\n          message = {\n            data: message\n          };\n        }\n\n        stream.writeMessage(message, resolve);\n      }))).subscribe();\n      request.on('close', () => {\n        response.end();\n        subscription.unsubscribe();\n      });\n    })();\n  }\n\n  assertObservable(result) {\n    if (!shared_utils_1.isFunction(result.subscribe)) {\n      throw new ReferenceError('You must return an Observable stream to use Server-Sent Events (SSE).');\n    }\n  }\n\n}\n\nexports.RouterResponseController = RouterResponseController;","map":null,"metadata":{},"sourceType":"script"}
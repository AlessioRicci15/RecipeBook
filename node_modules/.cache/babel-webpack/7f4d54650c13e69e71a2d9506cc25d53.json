{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/alessioricci/projects/udemy/udemy-app/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NestApplicationContext = void 0;\n\nconst common_1 = require(\"@nestjs/common\");\n\nconst interfaces_1 = require(\"@nestjs/common/interfaces\");\n\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\n\nconst iterare_1 = require(\"iterare\");\n\nconst constants_1 = require(\"./constants\");\n\nconst invalid_class_scope_exception_1 = require(\"./errors/exceptions/invalid-class-scope.exception\");\n\nconst unknown_element_exception_1 = require(\"./errors/exceptions/unknown-element.exception\");\n\nconst unknown_module_exception_1 = require(\"./errors/exceptions/unknown-module.exception\");\n\nconst helpers_1 = require(\"./helpers\");\n\nconst hooks_1 = require(\"./hooks\");\n\nconst compiler_1 = require(\"./injector/compiler\");\n\nconst injector_1 = require(\"./injector/injector\");\n\nconst instance_links_host_1 = require(\"./injector/instance-links-host\");\n/**\n * @publicApi\n */\n\n\nclass NestApplicationContext {\n  constructor(container, scope = new Array(), contextModule = null) {\n    this.container = container;\n    this.scope = scope;\n    this.contextModule = contextModule;\n    this.isInitialized = false;\n    this.injector = new injector_1.Injector();\n    this.activeShutdownSignals = new Array();\n    this.moduleCompiler = new compiler_1.ModuleCompiler();\n  }\n\n  get instanceLinksHost() {\n    if (!this._instanceLinksHost) {\n      this._instanceLinksHost = new instance_links_host_1.InstanceLinksHost(this.container);\n    }\n\n    return this._instanceLinksHost;\n  }\n\n  selectContextModule() {\n    const modules = this.container.getModules().values();\n    this.contextModule = modules.next().value;\n  }\n\n  select(moduleType) {\n    const modulesContainer = this.container.getModules();\n    const contextModuleCtor = this.contextModule.metatype;\n    const scope = this.scope.concat(contextModuleCtor);\n    const moduleTokenFactory = this.container.getModuleTokenFactory();\n    const {\n      type,\n      dynamicMetadata\n    } = this.moduleCompiler.extractMetadata(moduleType);\n    const token = moduleTokenFactory.create(type, dynamicMetadata);\n    const selectedModule = modulesContainer.get(token);\n\n    if (!selectedModule) {\n      throw new unknown_module_exception_1.UnknownModuleException();\n    }\n\n    return new NestApplicationContext(this.container, scope, selectedModule);\n  }\n\n  get(typeOrToken, options = {\n    strict: false\n  }) {\n    return !(options && options.strict) ? this.find(typeOrToken) : this.find(typeOrToken, this.contextModule);\n  }\n\n  resolve(typeOrToken, contextId = helpers_1.createContextId(), options = {\n    strict: false\n  }) {\n    return this.resolvePerContext(typeOrToken, this.contextModule, contextId, options);\n  }\n\n  registerRequestByContextId(request, contextId) {\n    this.container.registerRequestProvider(request, contextId);\n  }\n  /**\n   * Initalizes the Nest application.\n   * Calls the Nest lifecycle events.\n   *\n   * @returns {Promise<this>} The NestApplicationContext instance as Promise\n   */\n\n\n  init() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.isInitialized) {\n        return _this;\n      }\n\n      yield _this.callInitHook();\n      yield _this.callBootstrapHook();\n      _this.isInitialized = true;\n      return _this;\n    })();\n  }\n\n  close() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this2.callDestroyHook();\n      yield _this2.callBeforeShutdownHook();\n      yield _this2.dispose();\n      yield _this2.callShutdownHook();\n\n      _this2.unsubscribeFromProcessSignals();\n    })();\n  }\n\n  useLogger(logger) {\n    common_1.Logger.overrideLogger(logger);\n  }\n  /**\n   * Enables the usage of shutdown hooks. Will call the\n   * `onApplicationShutdown` function of a provider if the\n   * process receives a shutdown signal.\n   *\n   * @param {ShutdownSignal[]} [signals=[]] The system signals it should listen to\n   *\n   * @returns {this} The Nest application context instance\n   */\n\n\n  enableShutdownHooks(signals = []) {\n    if (shared_utils_1.isEmpty(signals)) {\n      signals = Object.keys(common_1.ShutdownSignal).map(key => common_1.ShutdownSignal[key]);\n    } else {\n      // given signals array should be unique because\n      // process shouldn't listen to the same signal more than once.\n      signals = Array.from(new Set(signals));\n    }\n\n    signals = iterare_1.iterate(signals).map(signal => signal.toString().toUpperCase().trim()) // filter out the signals which is already listening to\n    .filter(signal => !this.activeShutdownSignals.includes(signal)).toArray();\n    this.listenToShutdownSignals(signals);\n    return this;\n  }\n\n  dispose() {\n    return _asyncToGenerator(function* () {\n      // Nest application context has no server\n      // to dispose, therefore just call a noop\n      return Promise.resolve();\n    })();\n  }\n  /**\n   * Listens to shutdown signals by listening to\n   * process events\n   *\n   * @param {string[]} signals The system signals it should listen to\n   */\n\n\n  listenToShutdownSignals(signals) {\n    var _this3 = this;\n\n    const cleanup = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (signal) {\n        var _a;\n\n        try {\n          signals.forEach(sig => process.removeListener(sig, cleanup));\n          yield _this3.callDestroyHook();\n          yield _this3.callBeforeShutdownHook(signal);\n          yield _this3.dispose();\n          yield _this3.callShutdownHook(signal);\n          process.kill(process.pid, signal);\n        } catch (err) {\n          common_1.Logger.error(constants_1.MESSAGES.ERROR_DURING_SHUTDOWN, (_a = err) === null || _a === void 0 ? void 0 : _a.stack, NestApplicationContext.name);\n          process.exit(1);\n        }\n      });\n\n      return function cleanup(_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    this.shutdownCleanupRef = cleanup;\n    signals.forEach(signal => {\n      this.activeShutdownSignals.push(signal);\n      process.on(signal, cleanup);\n    });\n  }\n  /**\n   * Unsubscribes from shutdown signals (process events)\n   */\n\n\n  unsubscribeFromProcessSignals() {\n    if (!this.shutdownCleanupRef) {\n      return;\n    }\n\n    this.activeShutdownSignals.forEach(signal => {\n      process.removeListener(signal, this.shutdownCleanupRef);\n    });\n  }\n  /**\n   * Calls the `onModuleInit` function on the registered\n   * modules and its children.\n   */\n\n\n  callInitHook() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const modulesContainer = _this4.container.getModules();\n\n      for (const module of [...modulesContainer.values()].reverse()) {\n        yield hooks_1.callModuleInitHook(module);\n      }\n    })();\n  }\n  /**\n   * Calls the `onModuleDestroy` function on the registered\n   * modules and its children.\n   */\n\n\n  callDestroyHook() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const modulesContainer = _this5.container.getModules();\n\n      for (const module of modulesContainer.values()) {\n        yield hooks_1.callModuleDestroyHook(module);\n      }\n    })();\n  }\n  /**\n   * Calls the `onApplicationBootstrap` function on the registered\n   * modules and its children.\n   */\n\n\n  callBootstrapHook() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const modulesContainer = _this6.container.getModules();\n\n      for (const module of [...modulesContainer.values()].reverse()) {\n        yield hooks_1.callModuleBootstrapHook(module);\n      }\n    })();\n  }\n  /**\n   * Calls the `onApplicationShutdown` function on the registered\n   * modules and children.\n   */\n\n\n  callShutdownHook(signal) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const modulesContainer = _this7.container.getModules();\n\n      for (const module of [...modulesContainer.values()].reverse()) {\n        yield hooks_1.callAppShutdownHook(module, signal);\n      }\n    })();\n  }\n  /**\n   * Calls the `beforeApplicationShutdown` function on the registered\n   * modules and children.\n   */\n\n\n  callBeforeShutdownHook(signal) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const modulesContainer = _this8.container.getModules();\n\n      for (const module of [...modulesContainer.values()].reverse()) {\n        yield hooks_1.callBeforeAppShutdownHook(module, signal);\n      }\n    })();\n  }\n\n  find(typeOrToken, contextModule) {\n    const moduleId = contextModule && contextModule.id;\n    const {\n      wrapperRef\n    } = this.instanceLinksHost.get(typeOrToken, moduleId);\n\n    if (wrapperRef.scope === interfaces_1.Scope.REQUEST || wrapperRef.scope === interfaces_1.Scope.TRANSIENT) {\n      throw new invalid_class_scope_exception_1.InvalidClassScopeException(typeOrToken);\n    }\n\n    return wrapperRef.instance;\n  }\n\n  resolvePerContext(typeOrToken, contextModule, contextId, options) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      const isStrictModeEnabled = options && options.strict;\n      const instanceLink = isStrictModeEnabled ? _this9.instanceLinksHost.get(typeOrToken, contextModule.id) : _this9.instanceLinksHost.get(typeOrToken);\n      const {\n        wrapperRef,\n        collection\n      } = instanceLink;\n\n      if (wrapperRef.isDependencyTreeStatic() && !wrapperRef.isTransient) {\n        return _this9.get(typeOrToken);\n      }\n\n      const ctorHost = wrapperRef.instance || {\n        constructor: typeOrToken\n      };\n      const instance = yield _this9.injector.loadPerContext(ctorHost, wrapperRef.host, collection, contextId);\n\n      if (!instance) {\n        throw new unknown_element_exception_1.UnknownElementException();\n      }\n\n      return instance;\n    })();\n  }\n\n}\n\nexports.NestApplicationContext = NestApplicationContext;","map":null,"metadata":{},"sourceType":"script"}
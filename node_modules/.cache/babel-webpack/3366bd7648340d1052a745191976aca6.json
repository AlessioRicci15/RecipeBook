{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/alessioricci/projects/udemy/udemy-app/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValidationPipe = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst iterare_1 = require(\"iterare\");\n\nconst decorators_1 = require(\"../decorators\");\n\nconst core_1 = require(\"../decorators/core\");\n\nconst http_status_enum_1 = require(\"../enums/http-status.enum\");\n\nconst http_error_by_code_util_1 = require(\"../utils/http-error-by-code.util\");\n\nconst load_package_util_1 = require(\"../utils/load-package.util\");\n\nconst shared_utils_1 = require(\"../utils/shared.utils\");\n\nlet classValidator = {};\nlet classTransformer = {};\nlet ValidationPipe = class ValidationPipe {\n  constructor(options) {\n    options = options || {};\n\n    const {\n      transform,\n      disableErrorMessages,\n      errorHttpStatusCode,\n      expectedType,\n      transformOptions,\n      validateCustomDecorators\n    } = options,\n          validatorOptions = tslib_1.__rest(options, [\"transform\", \"disableErrorMessages\", \"errorHttpStatusCode\", \"expectedType\", \"transformOptions\", \"validateCustomDecorators\"]);\n\n    this.isTransformEnabled = !!transform;\n    this.validatorOptions = validatorOptions;\n    this.transformOptions = transformOptions;\n    this.isDetailedOutputDisabled = disableErrorMessages;\n    this.validateCustomDecorators = validateCustomDecorators || false;\n    this.errorHttpStatusCode = errorHttpStatusCode || http_status_enum_1.HttpStatus.BAD_REQUEST;\n    this.expectedType = expectedType;\n    this.exceptionFactory = options.exceptionFactory || this.createExceptionFactory();\n    classValidator = this.loadValidator();\n    classTransformer = this.loadTransformer();\n  }\n\n  loadValidator() {\n    return load_package_util_1.loadPackage('class-validator', 'ValidationPipe', () => require('class-validator'));\n  }\n\n  loadTransformer() {\n    return load_package_util_1.loadPackage('class-transformer', 'ValidationPipe', () => require('class-transformer'));\n  }\n\n  transform(value, metadata) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.expectedType) {\n        metadata = Object.assign(Object.assign({}, metadata), {\n          metatype: _this.expectedType\n        });\n      }\n\n      const metatype = metadata.metatype;\n\n      if (!metatype || !_this.toValidate(metadata)) {\n        return _this.isTransformEnabled ? _this.transformPrimitive(value, metadata) : value;\n      }\n\n      const originalValue = value;\n      value = _this.toEmptyIfNil(value);\n      const isNil = value !== originalValue;\n\n      const isPrimitive = _this.isPrimitive(value);\n\n      _this.stripProtoKeys(value);\n\n      let entity = classTransformer.plainToClass(metatype, value, _this.transformOptions);\n      const originalEntity = entity;\n      const isCtorNotEqual = entity.constructor !== metatype;\n\n      if (isCtorNotEqual && !isPrimitive) {\n        entity.constructor = metatype;\n      } else if (isCtorNotEqual) {\n        // when \"entity\" is a primitive value, we have to temporarily\n        // replace the entity to perform the validation against the original\n        // metatype defined inside the handler\n        entity = {\n          constructor: metatype\n        };\n      }\n\n      const errors = yield classValidator.validate(entity, _this.validatorOptions);\n\n      if (errors.length > 0) {\n        throw yield _this.exceptionFactory(errors);\n      }\n\n      if (isPrimitive) {\n        // if the value is a primitive value and the validation process has been successfully completed\n        // we have to revert the original value passed through the pipe\n        entity = originalEntity;\n      }\n\n      if (_this.isTransformEnabled) {\n        return entity;\n      }\n\n      if (isNil) {\n        // if the value was originally undefined or null, revert it back\n        return originalValue;\n      }\n\n      return Object.keys(_this.validatorOptions).length > 0 ? classTransformer.classToPlain(entity, _this.transformOptions) : value;\n    })();\n  }\n\n  createExceptionFactory() {\n    return (validationErrors = []) => {\n      if (this.isDetailedOutputDisabled) {\n        return new http_error_by_code_util_1.HttpErrorByCode[this.errorHttpStatusCode]();\n      }\n\n      const errors = this.flattenValidationErrors(validationErrors);\n      return new http_error_by_code_util_1.HttpErrorByCode[this.errorHttpStatusCode](errors);\n    };\n  }\n\n  toValidate(metadata) {\n    const {\n      metatype,\n      type\n    } = metadata;\n\n    if (type === 'custom' && !this.validateCustomDecorators) {\n      return false;\n    }\n\n    const types = [String, Boolean, Number, Array, Object, Buffer];\n    return !types.some(t => metatype === t) && !shared_utils_1.isNil(metatype);\n  }\n\n  transformPrimitive(value, metadata) {\n    if (!metadata.data) {\n      // leave top-level query/param objects unmodified\n      return value;\n    }\n\n    const {\n      type,\n      metatype\n    } = metadata;\n\n    if (type !== 'param' && type !== 'query') {\n      return value;\n    }\n\n    if (metatype === Boolean) {\n      return value === true || value === 'true';\n    }\n\n    if (metatype === Number) {\n      return +value;\n    }\n\n    return value;\n  }\n\n  toEmptyIfNil(value) {\n    return shared_utils_1.isNil(value) ? {} : value;\n  }\n\n  stripProtoKeys(value) {\n    delete value.__proto__;\n    const keys = Object.keys(value);\n    iterare_1.iterate(keys).filter(key => typeof value[key] === 'object' && value[key]).forEach(key => this.stripProtoKeys(value[key]));\n  }\n\n  isPrimitive(value) {\n    return ['number', 'boolean', 'string'].includes(typeof value);\n  }\n\n  flattenValidationErrors(validationErrors) {\n    return iterare_1.iterate(validationErrors).map(error => this.mapChildrenToValidationErrors(error)).flatten().filter(item => !!item.constraints).map(item => Object.values(item.constraints)).flatten().toArray();\n  }\n\n  mapChildrenToValidationErrors(error, parentPath) {\n    if (!(error.children && error.children.length)) {\n      return [error];\n    }\n\n    const validationErrors = [];\n    parentPath = parentPath ? `${parentPath}.${error.property}` : error.property;\n\n    for (const item of error.children) {\n      if (item.children && item.children.length) {\n        validationErrors.push(...this.mapChildrenToValidationErrors(item, parentPath));\n      }\n\n      validationErrors.push(this.prependConstraintsWithParentProp(parentPath, item));\n    }\n\n    return validationErrors;\n  }\n\n  prependConstraintsWithParentProp(parentPath, error) {\n    const constraints = {};\n\n    for (const key in error.constraints) {\n      constraints[key] = `${parentPath}.${error.constraints[key]}`;\n    }\n\n    return Object.assign(Object.assign({}, error), {\n      constraints\n    });\n  }\n\n};\nValidationPipe = tslib_1.__decorate([core_1.Injectable(), tslib_1.__param(0, decorators_1.Optional()), tslib_1.__metadata(\"design:paramtypes\", [Object])], ValidationPipe);\nexports.ValidationPipe = ValidationPipe;","map":null,"metadata":{},"sourceType":"script"}
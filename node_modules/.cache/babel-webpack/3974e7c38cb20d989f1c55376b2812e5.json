{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/alessioricci/projects/udemy/udemy-app/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ModuleRef = void 0;\n\nconst common_1 = require(\"@nestjs/common\");\n\nconst invalid_class_scope_exception_1 = require(\"../errors/exceptions/invalid-class-scope.exception\");\n\nconst unknown_element_exception_1 = require(\"../errors/exceptions/unknown-element.exception\");\n\nconst get_class_scope_1 = require(\"../helpers/get-class-scope\");\n\nconst injector_1 = require(\"./injector\");\n\nconst instance_links_host_1 = require(\"./instance-links-host\");\n\nconst instance_wrapper_1 = require(\"./instance-wrapper\");\n\nclass ModuleRef {\n  constructor(container) {\n    this.container = container;\n    this.injector = new injector_1.Injector();\n  }\n\n  get instanceLinksHost() {\n    if (!this._instanceLinksHost) {\n      this._instanceLinksHost = new instance_links_host_1.InstanceLinksHost(this.container);\n    }\n\n    return this._instanceLinksHost;\n  }\n\n  introspect(token) {\n    const {\n      wrapperRef\n    } = this.instanceLinksHost.get(token);\n    let scope = common_1.Scope.DEFAULT;\n\n    if (!wrapperRef.isDependencyTreeStatic()) {\n      scope = common_1.Scope.REQUEST;\n    } else if (wrapperRef.isTransient) {\n      scope = common_1.Scope.TRANSIENT;\n    }\n\n    return {\n      scope\n    };\n  }\n\n  registerRequestByContextId(request, contextId) {\n    this.container.registerRequestProvider(request, contextId);\n  }\n\n  find(typeOrToken, contextModule) {\n    const moduleId = contextModule && contextModule.id;\n    const {\n      wrapperRef\n    } = this.instanceLinksHost.get(typeOrToken, moduleId);\n\n    if (wrapperRef.scope === common_1.Scope.REQUEST || wrapperRef.scope === common_1.Scope.TRANSIENT) {\n      throw new invalid_class_scope_exception_1.InvalidClassScopeException(typeOrToken);\n    }\n\n    return wrapperRef.instance;\n  }\n\n  resolvePerContext(typeOrToken, contextModule, contextId, options) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const isStrictModeEnabled = options && options.strict;\n      const instanceLink = isStrictModeEnabled ? _this.instanceLinksHost.get(typeOrToken, contextModule.id) : _this.instanceLinksHost.get(typeOrToken);\n      const {\n        wrapperRef,\n        collection\n      } = instanceLink;\n\n      if (wrapperRef.isDependencyTreeStatic() && !wrapperRef.isTransient) {\n        return _this.get(typeOrToken);\n      }\n\n      const ctorHost = wrapperRef.instance || {\n        constructor: typeOrToken\n      };\n      const instance = yield _this.injector.loadPerContext(ctorHost, wrapperRef.host, collection, contextId, wrapperRef);\n\n      if (!instance) {\n        throw new unknown_element_exception_1.UnknownElementException();\n      }\n\n      return instance;\n    })();\n  }\n\n  instantiateClass(type, moduleRef) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const wrapper = new instance_wrapper_1.InstanceWrapper({\n        name: type && type.name,\n        metatype: type,\n        isResolved: false,\n        scope: get_class_scope_1.getClassScope(type),\n        host: moduleRef\n      });\n      return new Promise( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (resolve, reject) {\n          try {\n            const callback = /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator(function* (instances) {\n                const properties = yield _this2.injector.resolveProperties(wrapper, moduleRef);\n                const instance = new type(...instances);\n\n                _this2.injector.applyProperties(instance, properties);\n\n                resolve(instance);\n              });\n\n              return function callback(_x3) {\n                return _ref2.apply(this, arguments);\n              };\n            }();\n\n            yield _this2.injector.resolveConstructorParams(wrapper, moduleRef, undefined, callback);\n          } catch (err) {\n            reject(err);\n          }\n        });\n\n        return function (_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n\n}\n\nexports.ModuleRef = ModuleRef;","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/alessioricci/projects/udemy/udemy-app/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RouterExecutionContext = void 0;\n\nconst common_1 = require(\"@nestjs/common\");\n\nconst constants_1 = require(\"@nestjs/common/constants\");\n\nconst route_paramtypes_enum_1 = require(\"@nestjs/common/enums/route-paramtypes.enum\");\n\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\n\nconst constants_2 = require(\"../guards/constants\");\n\nconst context_utils_1 = require(\"../helpers/context-utils\");\n\nconst handler_metadata_storage_1 = require(\"../helpers/handler-metadata-storage\");\n\nconst constants_3 = require(\"../injector/constants\");\n\nconst router_response_controller_1 = require(\"./router-response-controller\");\n\nclass RouterExecutionContext {\n  constructor(paramsFactory, pipesContextCreator, pipesConsumer, guardsContextCreator, guardsConsumer, interceptorsContextCreator, interceptorsConsumer, applicationRef) {\n    this.paramsFactory = paramsFactory;\n    this.pipesContextCreator = pipesContextCreator;\n    this.pipesConsumer = pipesConsumer;\n    this.guardsContextCreator = guardsContextCreator;\n    this.guardsConsumer = guardsConsumer;\n    this.interceptorsContextCreator = interceptorsContextCreator;\n    this.interceptorsConsumer = interceptorsConsumer;\n    this.applicationRef = applicationRef;\n    this.handlerMetadataStorage = new handler_metadata_storage_1.HandlerMetadataStorage();\n    this.contextUtils = new context_utils_1.ContextUtils();\n    this.responseController = new router_response_controller_1.RouterResponseController(applicationRef);\n  }\n\n  create(instance, callback, methodName, moduleKey, requestMethod, contextId = constants_3.STATIC_CONTEXT, inquirerId) {\n    var _this = this;\n\n    const contextType = 'http';\n    const {\n      argsLength,\n      fnHandleResponse,\n      paramtypes,\n      getParamsMetadata,\n      httpStatusCode,\n      responseHeaders,\n      hasCustomHeaders\n    } = this.getMetadata(instance, callback, methodName, moduleKey, requestMethod, contextType);\n    const paramsOptions = this.contextUtils.mergeParamsMetatypes(getParamsMetadata(moduleKey, contextId, inquirerId), paramtypes);\n    const pipes = this.pipesContextCreator.create(instance, callback, moduleKey, contextId, inquirerId);\n    const guards = this.guardsContextCreator.create(instance, callback, moduleKey, contextId, inquirerId);\n    const interceptors = this.interceptorsContextCreator.create(instance, callback, moduleKey, contextId, inquirerId);\n    const fnCanActivate = this.createGuardsFn(guards, instance, callback, contextType);\n    const fnApplyPipes = this.createPipesFn(pipes, paramsOptions);\n\n    const handler = (args, req, res, next) => /*#__PURE__*/_asyncToGenerator(function* () {\n      fnApplyPipes && (yield fnApplyPipes(args, req, res, next));\n      return callback.apply(instance, args);\n    });\n\n    return /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (req, res, next) {\n        const args = _this.contextUtils.createNullArray(argsLength);\n\n        fnCanActivate && (yield fnCanActivate([req, res, next]));\n\n        _this.responseController.setStatus(res, httpStatusCode);\n\n        hasCustomHeaders && _this.responseController.setHeaders(res, responseHeaders);\n        const result = yield _this.interceptorsConsumer.intercept(interceptors, [req, res, next], instance, callback, handler(args, req, res, next), contextType);\n        yield fnHandleResponse(result, res, req);\n      });\n\n      return function (_x, _x2, _x3) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n  }\n\n  getMetadata(instance, callback, methodName, moduleKey, requestMethod, contextType) {\n    const cacheMetadata = this.handlerMetadataStorage.get(instance, methodName);\n\n    if (cacheMetadata) {\n      return cacheMetadata;\n    }\n\n    const metadata = this.contextUtils.reflectCallbackMetadata(instance, methodName, constants_1.ROUTE_ARGS_METADATA) || {};\n    const keys = Object.keys(metadata);\n    const argsLength = this.contextUtils.getArgumentsLength(keys, metadata);\n    const paramtypes = this.contextUtils.reflectCallbackParamtypes(instance, methodName);\n    const contextFactory = this.contextUtils.getContextFactory(contextType, instance, callback);\n\n    const getParamsMetadata = (moduleKey, contextId = constants_3.STATIC_CONTEXT, inquirerId) => this.exchangeKeysForValues(keys, metadata, moduleKey, contextId, inquirerId, contextFactory);\n\n    const paramsMetadata = getParamsMetadata(moduleKey);\n    const isResponseHandled = this.isResponseHandled(instance, methodName, paramsMetadata);\n    const httpRedirectResponse = this.reflectRedirect(callback);\n    const fnHandleResponse = this.createHandleResponseFn(callback, isResponseHandled, httpRedirectResponse);\n    const httpCode = this.reflectHttpStatusCode(callback);\n    const httpStatusCode = httpCode ? httpCode : this.responseController.getStatusByMethod(requestMethod);\n    const responseHeaders = this.reflectResponseHeaders(callback);\n    const hasCustomHeaders = !shared_utils_1.isEmpty(responseHeaders);\n    const handlerMetadata = {\n      argsLength,\n      fnHandleResponse,\n      paramtypes,\n      getParamsMetadata,\n      httpStatusCode,\n      hasCustomHeaders,\n      responseHeaders\n    };\n    this.handlerMetadataStorage.set(instance, methodName, handlerMetadata);\n    return handlerMetadata;\n  }\n\n  reflectRedirect(callback) {\n    return Reflect.getMetadata(constants_1.REDIRECT_METADATA, callback);\n  }\n\n  reflectHttpStatusCode(callback) {\n    return Reflect.getMetadata(constants_1.HTTP_CODE_METADATA, callback);\n  }\n\n  reflectRenderTemplate(callback) {\n    return Reflect.getMetadata(constants_1.RENDER_METADATA, callback);\n  }\n\n  reflectResponseHeaders(callback) {\n    return Reflect.getMetadata(constants_1.HEADERS_METADATA, callback) || [];\n  }\n\n  reflectSse(callback) {\n    return Reflect.getMetadata(constants_1.SSE_METADATA, callback);\n  }\n\n  exchangeKeysForValues(keys, metadata, moduleContext, contextId = constants_3.STATIC_CONTEXT, inquirerId, contextFactory) {\n    this.pipesContextCreator.setModuleContext(moduleContext);\n    return keys.map(key => {\n      const {\n        index,\n        data,\n        pipes: pipesCollection\n      } = metadata[key];\n      const pipes = this.pipesContextCreator.createConcreteContext(pipesCollection, contextId, inquirerId);\n      const type = this.contextUtils.mapParamType(key);\n\n      if (key.includes(constants_1.CUSTOM_ROUTE_AGRS_METADATA)) {\n        const {\n          factory\n        } = metadata[key];\n        const customExtractValue = this.contextUtils.getCustomFactory(factory, data, contextFactory);\n        return {\n          index,\n          extractValue: customExtractValue,\n          type,\n          data,\n          pipes\n        };\n      }\n\n      const numericType = Number(type);\n\n      const extractValue = (req, res, next) => this.paramsFactory.exchangeKeyForValue(numericType, data, {\n        req,\n        res,\n        next\n      });\n\n      return {\n        index,\n        extractValue,\n        type: numericType,\n        data,\n        pipes\n      };\n    });\n  }\n\n  getParamValue(value, {\n    metatype,\n    type,\n    data\n  }, pipes) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!shared_utils_1.isEmpty(pipes)) {\n        return _this2.pipesConsumer.apply(value, {\n          metatype,\n          type,\n          data\n        }, pipes);\n      }\n\n      return value;\n    })();\n  }\n\n  isPipeable(type) {\n    return type === route_paramtypes_enum_1.RouteParamtypes.BODY || type === route_paramtypes_enum_1.RouteParamtypes.QUERY || type === route_paramtypes_enum_1.RouteParamtypes.PARAM || type === route_paramtypes_enum_1.RouteParamtypes.FILE || type === route_paramtypes_enum_1.RouteParamtypes.FILES || shared_utils_1.isString(type);\n  }\n\n  createGuardsFn(guards, instance, callback, contextType) {\n    var _this3 = this;\n\n    const canActivateFn = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(function* (args) {\n        const canActivate = yield _this3.guardsConsumer.tryActivate(guards, args, instance, callback, contextType);\n\n        if (!canActivate) {\n          throw new common_1.ForbiddenException(constants_2.FORBIDDEN_MESSAGE);\n        }\n      });\n\n      return function canActivateFn(_x4) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n\n    return guards.length ? canActivateFn : null;\n  }\n\n  createPipesFn(pipes, paramsOptions) {\n    var _this4 = this;\n\n    const pipesFn = /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator(function* (args, req, res, next) {\n        const resolveParamValue = /*#__PURE__*/function () {\n          var _ref5 = _asyncToGenerator(function* (param) {\n            const {\n              index,\n              extractValue,\n              type,\n              data,\n              metatype,\n              pipes: paramPipes\n            } = param;\n            const value = extractValue(req, res, next);\n            args[index] = _this4.isPipeable(type) ? yield _this4.getParamValue(value, {\n              metatype,\n              type,\n              data\n            }, pipes.concat(paramPipes)) : value;\n          });\n\n          return function resolveParamValue(_x9) {\n            return _ref5.apply(this, arguments);\n          };\n        }();\n\n        yield Promise.all(paramsOptions.map(resolveParamValue));\n      });\n\n      return function pipesFn(_x5, _x6, _x7, _x8) {\n        return _ref4.apply(this, arguments);\n      };\n    }();\n\n    return paramsOptions.length ? pipesFn : null;\n  }\n\n  createHandleResponseFn(callback, isResponseHandled, redirectResponse, httpStatusCode) {\n    var _this5 = this;\n\n    const renderTemplate = this.reflectRenderTemplate(callback);\n\n    if (renderTemplate) {\n      return /*#__PURE__*/function () {\n        var _ref6 = _asyncToGenerator(function* (result, res) {\n          return yield _this5.responseController.render(result, res, renderTemplate);\n        });\n\n        return function (_x10, _x11) {\n          return _ref6.apply(this, arguments);\n        };\n      }();\n    }\n\n    if (redirectResponse && typeof redirectResponse.url === 'string') {\n      return /*#__PURE__*/function () {\n        var _ref7 = _asyncToGenerator(function* (result, res) {\n          yield _this5.responseController.redirect(result, res, redirectResponse);\n        });\n\n        return function (_x12, _x13) {\n          return _ref7.apply(this, arguments);\n        };\n      }();\n    }\n\n    const isSseHandler = !!this.reflectSse(callback);\n\n    if (isSseHandler) {\n      return /*#__PURE__*/function () {\n        var _ref8 = _asyncToGenerator(function* (result, res, req) {\n          yield _this5.responseController.sse(result, res.raw || res, req.raw || req);\n        });\n\n        return function (_x14, _x15, _x16) {\n          return _ref8.apply(this, arguments);\n        };\n      }();\n    }\n\n    return /*#__PURE__*/function () {\n      var _ref9 = _asyncToGenerator(function* (result, res) {\n        result = yield _this5.responseController.transformToResult(result);\n        !isResponseHandled && (yield _this5.responseController.apply(result, res, httpStatusCode));\n      });\n\n      return function (_x17, _x18) {\n        return _ref9.apply(this, arguments);\n      };\n    }();\n  }\n\n  isResponseHandled(instance, methodName, paramsMetadata) {\n    const hasResponseOrNextDecorator = paramsMetadata.some(({\n      type\n    }) => type === route_paramtypes_enum_1.RouteParamtypes.RESPONSE || type === route_paramtypes_enum_1.RouteParamtypes.NEXT);\n    const isPassthroughEnabled = this.contextUtils.reflectPassthrough(instance, methodName);\n    return hasResponseOrNextDecorator && !isPassthroughEnabled;\n  }\n\n}\n\nexports.RouterExecutionContext = RouterExecutionContext;","map":null,"metadata":{},"sourceType":"script"}
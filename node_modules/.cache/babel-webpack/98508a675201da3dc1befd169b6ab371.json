{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/alessioricci/projects/udemy/udemy-app/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParseArrayPipe = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst injectable_decorator_1 = require(\"../decorators/core/injectable.decorator\");\n\nconst optional_decorator_1 = require(\"../decorators/core/optional.decorator\");\n\nconst http_status_enum_1 = require(\"../enums/http-status.enum\");\n\nconst http_error_by_code_util_1 = require(\"../utils/http-error-by-code.util\");\n\nconst shared_utils_1 = require(\"../utils/shared.utils\");\n\nconst validation_pipe_1 = require(\"./validation.pipe\");\n\nconst VALIDATION_ERROR_MESSAGE = 'Validation failed (parsable array expected)';\nconst DEFAULT_ARRAY_SEPARATOR = ',';\n/**\n * Defines the built-in ParseArray Pipe\n *\n * @see [Built-in Pipes](https://docs.nestjs.com/pipes#built-in-pipes)\n *\n * @publicApi\n */\n\nlet ParseArrayPipe = class ParseArrayPipe {\n  constructor(options = {}) {\n    this.options = options;\n    this.validationPipe = new validation_pipe_1.ValidationPipe(Object.assign({\n      transform: true,\n      validateCustomDecorators: true\n    }, options));\n    const {\n      exceptionFactory,\n      errorHttpStatusCode = http_status_enum_1.HttpStatus.BAD_REQUEST\n    } = options;\n\n    this.exceptionFactory = exceptionFactory || (error => new http_error_by_code_util_1.HttpErrorByCode[errorHttpStatusCode](error));\n  }\n  /**\n   * Method that accesses and performs optional transformation on argument for\n   * in-flight requests.\n   *\n   * @param value currently processed route argument\n   * @param metadata contains metadata about the currently processed route argument\n   */\n\n\n  transform(value, metadata) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!value && !_this.options.optional) {\n        throw _this.exceptionFactory(VALIDATION_ERROR_MESSAGE);\n      } else if (shared_utils_1.isNil(value) && _this.options.optional) {\n        return value;\n      }\n\n      if (!Array.isArray(value)) {\n        if (!shared_utils_1.isString(value)) {\n          throw _this.exceptionFactory(VALIDATION_ERROR_MESSAGE);\n        } else {\n          try {\n            value = value.trim().split(_this.options.separator || DEFAULT_ARRAY_SEPARATOR);\n          } catch (_a) {\n            throw _this.exceptionFactory(VALIDATION_ERROR_MESSAGE);\n          }\n        }\n      }\n\n      if (_this.options.items) {\n        const validationMetadata = {\n          metatype: _this.options.items,\n          type: 'query'\n        };\n\n        const toClassInstance = item => {\n          try {\n            item = JSON.parse(item);\n          } catch (_a) {}\n\n          return _this.validationPipe.transform(item, validationMetadata);\n        };\n\n        if (_this.options.stopAtFirstError === false) {\n          // strict compare to \"false\" to make sure\n          // that this option is disabled by default\n          let errors = [];\n          const targetArray = value;\n\n          for (let i = 0; i < targetArray.length; i++) {\n            try {\n              targetArray[i] = yield toClassInstance(targetArray[i]);\n            } catch (err) {\n              let message;\n\n              if (err.getResponse) {\n                const response = err.getResponse();\n\n                if (Array.isArray(response.message)) {\n                  message = response.message.map(item => `[${i}] ${item}`);\n                } else {\n                  message = `[${i}] ${response.message}`;\n                }\n              } else {\n                message = err;\n              }\n\n              errors = errors.concat(message);\n            }\n          }\n\n          if (errors.length > 0) {\n            throw _this.exceptionFactory(errors);\n          }\n\n          return targetArray;\n        } else {\n          value = yield Promise.all(value.map(toClassInstance));\n        }\n      }\n\n      return value;\n    })();\n  }\n\n};\nParseArrayPipe = tslib_1.__decorate([injectable_decorator_1.Injectable(), tslib_1.__param(0, optional_decorator_1.Optional()), tslib_1.__metadata(\"design:paramtypes\", [Object])], ParseArrayPipe);\nexports.ParseArrayPipe = ParseArrayPipe;","map":null,"metadata":{},"sourceType":"script"}
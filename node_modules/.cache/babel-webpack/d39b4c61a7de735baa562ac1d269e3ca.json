{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/alessioricci/projects/udemy/udemy-app/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NestFactory = exports.NestFactoryStatic = void 0;\n\nconst logger_service_1 = require(\"@nestjs/common/services/logger.service\");\n\nconst load_package_util_1 = require(\"@nestjs/common/utils/load-package.util\");\n\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\n\nconst application_config_1 = require(\"./application-config\");\n\nconst constants_1 = require(\"./constants\");\n\nconst exceptions_zone_1 = require(\"./errors/exceptions-zone\");\n\nconst load_adapter_1 = require(\"./helpers/load-adapter\");\n\nconst rethrow_1 = require(\"./helpers/rethrow\");\n\nconst container_1 = require(\"./injector/container\");\n\nconst instance_loader_1 = require(\"./injector/instance-loader\");\n\nconst metadata_scanner_1 = require(\"./metadata-scanner\");\n\nconst nest_application_1 = require(\"./nest-application\");\n\nconst nest_application_context_1 = require(\"./nest-application-context\");\n\nconst scanner_1 = require(\"./scanner\");\n/**\n * @publicApi\n */\n\n\nclass NestFactoryStatic {\n  constructor() {\n    this.logger = new logger_service_1.Logger('NestFactory', true);\n    this.abortOnError = true;\n  }\n\n  create(module, serverOrOptions, options) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const [httpServer, appOptions] = _this.isHttpServer(serverOrOptions) ? [serverOrOptions, options] : [_this.createHttpAdapter(), serverOrOptions];\n      const applicationConfig = new application_config_1.ApplicationConfig();\n      const container = new container_1.NestContainer(applicationConfig);\n\n      _this.setAbortOnError(serverOrOptions, options);\n\n      _this.applyLogger(appOptions);\n\n      yield _this.initialize(module, container, applicationConfig, httpServer);\n      const instance = new nest_application_1.NestApplication(container, httpServer, applicationConfig, appOptions);\n\n      const target = _this.createNestInstance(instance);\n\n      return _this.createAdapterProxy(target, httpServer);\n    })();\n  }\n  /**\n   * Creates an instance of NestMicroservice.\n   *\n   * @param module Entry (root) application module class\n   * @param options Optional microservice configuration\n   *\n   * @returns A promise that, when resolved,\n   * contains a reference to the NestMicroservice instance.\n   */\n\n\n  createMicroservice(module, options) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        NestMicroservice\n      } = load_package_util_1.loadPackage('@nestjs/microservices', 'NestFactory', () => require('@nestjs/microservices'));\n      const applicationConfig = new application_config_1.ApplicationConfig();\n      const container = new container_1.NestContainer(applicationConfig);\n\n      _this2.setAbortOnError(options);\n\n      _this2.applyLogger(options);\n\n      yield _this2.initialize(module, container, applicationConfig);\n      return _this2.createNestInstance(new NestMicroservice(container, options, applicationConfig));\n    })();\n  }\n  /**\n   * Creates an instance of NestApplicationContext.\n   *\n   * @param module Entry (root) application module class\n   * @param options Optional Nest application configuration\n   *\n   * @returns A promise that, when resolved,\n   * contains a reference to the NestApplicationContext instance.\n   */\n\n\n  createApplicationContext(module, options) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const container = new container_1.NestContainer();\n\n      _this3.setAbortOnError(options);\n\n      _this3.applyLogger(options);\n\n      yield _this3.initialize(module, container);\n      const modules = container.getModules().values();\n      const root = modules.next().value;\n\n      const context = _this3.createNestInstance(new nest_application_context_1.NestApplicationContext(container, [], root));\n\n      return context.init();\n    })();\n  }\n\n  createNestInstance(instance) {\n    return this.createProxy(instance);\n  }\n\n  initialize(module, container, config = new application_config_1.ApplicationConfig(), httpServer = null) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const instanceLoader = new instance_loader_1.InstanceLoader(container);\n      const metadataScanner = new metadata_scanner_1.MetadataScanner();\n      const dependenciesScanner = new scanner_1.DependenciesScanner(container, metadataScanner, config);\n      container.setHttpAdapter(httpServer);\n      const teardown = _this4.abortOnError === false ? rethrow_1.rethrow : undefined;\n      yield httpServer === null || httpServer === void 0 ? void 0 : httpServer.init();\n\n      try {\n        _this4.logger.log(constants_1.MESSAGES.APPLICATION_START);\n\n        yield exceptions_zone_1.ExceptionsZone.asyncRun( /*#__PURE__*/_asyncToGenerator(function* () {\n          yield dependenciesScanner.scan(module);\n          yield instanceLoader.createInstancesOfDependencies();\n          dependenciesScanner.applyApplicationProviders();\n        }), teardown);\n      } catch (e) {\n        _this4.handleInitializationError(e);\n      }\n    })();\n  }\n\n  handleInitializationError(err) {\n    if (this.abortOnError) {\n      process.abort();\n    }\n\n    rethrow_1.rethrow(err);\n  }\n\n  createProxy(target) {\n    const proxy = this.createExceptionProxy();\n    return new Proxy(target, {\n      get: proxy,\n      set: proxy\n    });\n  }\n\n  createExceptionProxy() {\n    return (receiver, prop) => {\n      if (!(prop in receiver)) {\n        return;\n      }\n\n      if (shared_utils_1.isFunction(receiver[prop])) {\n        return this.createExceptionZone(receiver, prop);\n      }\n\n      return receiver[prop];\n    };\n  }\n\n  createExceptionZone(receiver, prop) {\n    const teardown = this.abortOnError === false ? rethrow_1.rethrow : undefined;\n    return (...args) => {\n      let result;\n      exceptions_zone_1.ExceptionsZone.run(() => {\n        result = receiver[prop](...args);\n      }, teardown);\n      return result;\n    };\n  }\n\n  applyLogger(options) {\n    if (!options || (options === null || options === void 0 ? void 0 : options.logger) === true || shared_utils_1.isNil(options === null || options === void 0 ? void 0 : options.logger)) {\n      return;\n    }\n\n    logger_service_1.Logger.overrideLogger(options.logger);\n  }\n\n  createHttpAdapter(httpServer) {\n    const {\n      ExpressAdapter\n    } = load_adapter_1.loadAdapter('@nestjs/platform-express', 'HTTP', () => require('@nestjs/platform-express'));\n    return new ExpressAdapter(httpServer);\n  }\n\n  isHttpServer(serverOrOptions) {\n    return !!(serverOrOptions && serverOrOptions.patch);\n  }\n\n  setAbortOnError(serverOrOptions, options) {\n    this.abortOnError = this.isHttpServer(serverOrOptions) ? !(options && options.abortOnError === false) : !(serverOrOptions && serverOrOptions.abortOnError === false);\n  }\n\n  createAdapterProxy(app, adapter) {\n    const proxy = new Proxy(app, {\n      get: (receiver, prop) => {\n        const mapToProxy = result => {\n          return result instanceof Promise ? result.then(mapToProxy) : result instanceof nest_application_1.NestApplication ? proxy : result;\n        };\n\n        if (!(prop in receiver) && prop in adapter) {\n          return (...args) => {\n            const result = this.createExceptionZone(adapter, prop)(...args);\n            return mapToProxy(result);\n          };\n        }\n\n        if (shared_utils_1.isFunction(receiver[prop])) {\n          return (...args) => {\n            const result = receiver[prop](...args);\n            return mapToProxy(result);\n          };\n        }\n\n        return receiver[prop];\n      }\n    });\n    return proxy;\n  }\n\n}\n\nexports.NestFactoryStatic = NestFactoryStatic;\n/**\n * Use NestFactory to create an application instance.\n *\n * ### Specifying an entry module\n *\n * Pass the required *root module* for the application via the module parameter.\n * By convention, it is usually called `ApplicationModule`.  Starting with this\n * module, Nest assembles the dependency graph and begins the process of\n * Dependency Injection and instantiates the classes needed to launch your\n * application.\n *\n * @publicApi\n */\n\nexports.NestFactory = new NestFactoryStatic();","map":null,"metadata":{},"sourceType":"script"}
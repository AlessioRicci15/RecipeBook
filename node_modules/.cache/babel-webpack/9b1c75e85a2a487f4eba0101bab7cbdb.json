{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ValidationError_1 = require(\"./ValidationError\");\n\nvar MetadataStorage_1 = require(\"../metadata/MetadataStorage\");\n\nvar container_1 = require(\"../container\");\n\nvar ValidationTypes_1 = require(\"./ValidationTypes\");\n\nvar ValidationUtils_1 = require(\"./ValidationUtils\");\n/**\n * Executes validation over given object.\n */\n\n\nvar ValidationExecutor = function () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function ValidationExecutor(validator, validatorOptions) {\n    this.validator = validator;\n    this.validatorOptions = validatorOptions; // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    this.awaitingPromises = [];\n    this.ignoreAsyncValidations = false; // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    this.metadataStorage = container_1.getFromContainer(MetadataStorage_1.MetadataStorage);\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  ValidationExecutor.prototype.execute = function (object, targetSchema, validationErrors) {\n    var _this = this;\n    /**\n     * If there is no metadata registered it means possibly the dependencies are not flatterned and\n     * more than one instance is used.\n     *\n     * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n     */\n\n\n    if (!this.metadataStorage.hasValidationMetaData) {\n      console.warn(\"No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.\");\n    }\n\n    var groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n    var targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, groups);\n    var groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n    if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n      var validationError = new ValidationError_1.ValidationError();\n      if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === undefined || this.validatorOptions.validationError.target === true) validationError.target = object;\n      validationError.value = undefined;\n      validationError.property = undefined;\n      validationError.children = [];\n      validationError.constraints = {\n        unknownValue: \"an unknown value was passed to the validate function\"\n      };\n      validationErrors.push(validationError);\n      return;\n    }\n\n    if (this.validatorOptions && this.validatorOptions.whitelist) this.whitelist(object, groupedMetadatas, validationErrors); // General validation\n\n    Object.keys(groupedMetadatas).forEach(function (propertyName) {\n      var value = object[propertyName];\n      var definedMetadatas = groupedMetadatas[propertyName].filter(function (metadata) {\n        return metadata.type === ValidationTypes_1.ValidationTypes.IS_DEFINED;\n      });\n      var metadatas = groupedMetadatas[propertyName].filter(function (metadata) {\n        return metadata.type !== ValidationTypes_1.ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes_1.ValidationTypes.WHITELIST;\n      });\n      var customValidationMetadatas = metadatas.filter(function (metadata) {\n        return metadata.type === ValidationTypes_1.ValidationTypes.CUSTOM_VALIDATION;\n      });\n      var nestedValidationMetadatas = metadatas.filter(function (metadata) {\n        return metadata.type === ValidationTypes_1.ValidationTypes.NESTED_VALIDATION;\n      });\n      var conditionalValidationMetadatas = metadatas.filter(function (metadata) {\n        return metadata.type === ValidationTypes_1.ValidationTypes.CONDITIONAL_VALIDATION;\n      });\n\n      var validationError = _this.generateValidationError(object, value, propertyName);\n\n      validationErrors.push(validationError);\n\n      var canValidate = _this.conditionalValidations(object, value, conditionalValidationMetadatas);\n\n      if (!canValidate) {\n        return;\n      } // handle IS_DEFINED validation type the special way - it should work no matter skipMissingProperties is set or not\n\n\n      _this.defaultValidations(object, value, definedMetadatas, validationError.constraints);\n\n      if ((value === null || value === undefined) && _this.validatorOptions && _this.validatorOptions.skipMissingProperties === true) {\n        return;\n      }\n\n      _this.defaultValidations(object, value, metadatas, validationError.constraints);\n\n      _this.customValidations(object, value, customValidationMetadatas, validationError.constraints);\n\n      _this.nestedValidations(value, nestedValidationMetadatas, validationError.children);\n\n      _this.mapContexts(object, value, metadatas, validationError);\n    });\n  };\n\n  ValidationExecutor.prototype.whitelist = function (object, groupedMetadatas, validationErrors) {\n    var notAllowedProperties = [];\n    Object.keys(object).forEach(function (propertyName) {\n      // does this property have no metadata?\n      if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0) notAllowedProperties.push(propertyName);\n    });\n\n    if (notAllowedProperties.length > 0) {\n      if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n        // throw errors\n        notAllowedProperties.forEach(function (property) {\n          var _a;\n\n          validationErrors.push({\n            target: object,\n            property: property,\n            value: object[property],\n            children: undefined,\n            constraints: (_a = {}, _a[ValidationTypes_1.ValidationTypes.WHITELIST] = \"property \" + property + \" should not exist\", _a)\n          });\n        });\n      } else {\n        // strip non allowed properties\n        notAllowedProperties.forEach(function (property) {\n          return delete object[property];\n        });\n      }\n    }\n  };\n\n  ValidationExecutor.prototype.stripEmptyErrors = function (errors) {\n    var _this = this;\n\n    return errors.filter(function (error) {\n      if (error.children) {\n        error.children = _this.stripEmptyErrors(error.children);\n      }\n\n      if (Object.keys(error.constraints).length === 0) {\n        if (error.children.length === 0) {\n          return false;\n        } else {\n          delete error.constraints;\n        }\n      }\n\n      return true;\n    });\n  }; // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n\n\n  ValidationExecutor.prototype.generateValidationError = function (object, value, propertyName) {\n    var validationError = new ValidationError_1.ValidationError();\n    if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === undefined || this.validatorOptions.validationError.target === true) validationError.target = object;\n    if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.value === undefined || this.validatorOptions.validationError.value === true) validationError.value = value;\n    validationError.property = propertyName;\n    validationError.children = [];\n    validationError.constraints = {};\n    return validationError;\n  };\n\n  ValidationExecutor.prototype.conditionalValidations = function (object, value, metadatas) {\n    return metadatas.map(function (metadata) {\n      return metadata.constraints[0](object, value);\n    }).reduce(function (resultA, resultB) {\n      return resultA && resultB;\n    }, true);\n  };\n\n  ValidationExecutor.prototype.defaultValidations = function (object, value, metadatas, errorMap) {\n    var _this = this;\n\n    return metadatas.filter(function (metadata) {\n      if (metadata.each) {\n        if (value instanceof Array) {\n          return !value.every(function (subValue) {\n            return _this.validator.validateValueByMetadata(subValue, metadata);\n          });\n        }\n      } else {\n        return !_this.validator.validateValueByMetadata(value, metadata);\n      }\n    }).forEach(function (metadata) {\n      var _a = _this.createValidationError(object, value, metadata),\n          key = _a[0],\n          message = _a[1];\n\n      errorMap[key] = message;\n    });\n  };\n\n  ValidationExecutor.prototype.customValidations = function (object, value, metadatas, errorMap) {\n    var _this = this;\n\n    metadatas.forEach(function (metadata) {\n      container_1.getFromContainer(MetadataStorage_1.MetadataStorage).getTargetValidatorConstraints(metadata.constraintCls).forEach(function (customConstraintMetadata) {\n        if (customConstraintMetadata.async && _this.ignoreAsyncValidations) return;\n        var validationArguments = {\n          targetName: object.constructor ? object.constructor.name : undefined,\n          property: metadata.propertyName,\n          object: object,\n          value: value,\n          constraints: metadata.constraints\n        };\n        var validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n\n        if (validatedValue instanceof Promise) {\n          var promise = validatedValue.then(function (isValid) {\n            if (!isValid) {\n              var _a = _this.createValidationError(object, value, metadata, customConstraintMetadata),\n                  type = _a[0],\n                  message = _a[1];\n\n              errorMap[type] = message;\n            }\n          });\n\n          _this.awaitingPromises.push(promise);\n        } else {\n          if (!validatedValue) {\n            var _a = _this.createValidationError(object, value, metadata, customConstraintMetadata),\n                type = _a[0],\n                message = _a[1];\n\n            errorMap[type] = message;\n          }\n        }\n      });\n    });\n  };\n\n  ValidationExecutor.prototype.nestedValidations = function (value, metadatas, errors) {\n    var _this = this;\n\n    if (value === void 0) {\n      return;\n    }\n\n    metadatas.forEach(function (metadata) {\n      var _a;\n\n      if (metadata.type !== ValidationTypes_1.ValidationTypes.NESTED_VALIDATION) return;\n      var targetSchema = typeof metadata.target === \"string\" ? metadata.target : undefined;\n\n      if (value instanceof Array) {\n        value.forEach(function (subValue, index) {\n          var validationError = _this.generateValidationError(value, subValue, index.toString());\n\n          errors.push(validationError);\n\n          _this.execute(subValue, targetSchema, validationError.children);\n        });\n      } else if (value instanceof Object) {\n        _this.execute(value, targetSchema, errors);\n      } else {\n        var error = new ValidationError_1.ValidationError();\n        error.value = value;\n        error.property = metadata.propertyName;\n        error.target = metadata.target;\n\n        var _b = _this.createValidationError(metadata.target, value, metadata),\n            type = _b[0],\n            message = _b[1];\n\n        error.constraints = (_a = {}, _a[type] = message, _a);\n        errors.push(error);\n      }\n    });\n  };\n\n  ValidationExecutor.prototype.mapContexts = function (object, value, metadatas, error) {\n    var _this = this;\n\n    return metadatas.forEach(function (metadata) {\n      if (metadata.context) {\n        var type = _this.getConstraintType(metadata);\n\n        if (error.constraints[type]) {\n          if (!error.contexts) {\n            error.contexts = {};\n          }\n\n          error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n        }\n      }\n    });\n  };\n\n  ValidationExecutor.prototype.createValidationError = function (object, value, metadata, customValidatorMetadata) {\n    var targetName = object.constructor ? object.constructor.name : undefined;\n    var type = this.getConstraintType(metadata, customValidatorMetadata);\n    var validationArguments = {\n      targetName: targetName,\n      property: metadata.propertyName,\n      object: object,\n      value: value,\n      constraints: metadata.constraints\n    };\n    var message = metadata.message;\n\n    if (!metadata.message && (!this.validatorOptions || this.validatorOptions && !this.validatorOptions.dismissDefaultMessages)) {\n      if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n        message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n      }\n\n      if (!message) message = ValidationTypes_1.ValidationTypes.getMessage(type, metadata.each);\n    }\n\n    var messageString = ValidationUtils_1.ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n    return [type, messageString];\n  };\n\n  ValidationExecutor.prototype.getConstraintType = function (metadata, customValidatorMetadata) {\n    var type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n    return type;\n  };\n\n  return ValidationExecutor;\n}();\n\nexports.ValidationExecutor = ValidationExecutor; //# sourceMappingURL=ValidationExecutor.js.map","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/alessioricci/projects/udemy/udemy-app/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Injector = void 0;\n\nconst constants_1 = require(\"@nestjs/common/constants\");\n\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\n\nconst iterare_1 = require(\"iterare\");\n\nconst runtime_exception_1 = require(\"../errors/exceptions/runtime.exception\");\n\nconst undefined_dependency_exception_1 = require(\"../errors/exceptions/undefined-dependency.exception\");\n\nconst unknown_dependencies_exception_1 = require(\"../errors/exceptions/unknown-dependencies.exception\");\n\nconst constants_2 = require(\"./constants\");\n\nconst inquirer_1 = require(\"./inquirer\");\n\nconst instance_wrapper_1 = require(\"./instance-wrapper\");\n\nclass Injector {\n  loadPrototype({\n    name\n  }, collection, contextId = constants_2.STATIC_CONTEXT) {\n    if (!collection) {\n      return;\n    }\n\n    const target = collection.get(name);\n    const instance = target.createPrototype(contextId);\n\n    if (instance) {\n      const wrapper = new instance_wrapper_1.InstanceWrapper(Object.assign(Object.assign({}, target), {\n        instance\n      }));\n      collection.set(name, wrapper);\n    }\n  }\n\n  loadInstance(wrapper, collection, moduleRef, contextId = constants_2.STATIC_CONTEXT, inquirer) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const inquirerId = _this.getInquirerId(inquirer);\n\n      const instanceHost = wrapper.getInstanceByContextId(contextId, inquirerId);\n\n      if (instanceHost.isPending) {\n        return instanceHost.donePromise;\n      }\n\n      const done = _this.applyDoneHook(instanceHost);\n\n      const {\n        name,\n        inject\n      } = wrapper;\n      const targetWrapper = collection.get(name);\n\n      if (shared_utils_1.isUndefined(targetWrapper)) {\n        throw new runtime_exception_1.RuntimeException();\n      }\n\n      if (instanceHost.isResolved) {\n        return done();\n      }\n\n      const callback = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (instances) {\n          const properties = yield _this.resolveProperties(wrapper, moduleRef, inject, contextId, wrapper, inquirer);\n          const instance = yield _this.instantiateClass(instances, wrapper, targetWrapper, contextId, inquirer);\n\n          _this.applyProperties(instance, properties);\n\n          done();\n        });\n\n        return function callback(_x) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      yield _this.resolveConstructorParams(wrapper, moduleRef, inject, callback, contextId, wrapper, inquirer);\n    })();\n  }\n\n  loadMiddleware(wrapper, collection, moduleRef, contextId = constants_2.STATIC_CONTEXT, inquirer) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        metatype\n      } = wrapper;\n      const targetWrapper = collection.get(metatype.name);\n\n      if (!shared_utils_1.isUndefined(targetWrapper.instance)) {\n        return;\n      }\n\n      targetWrapper.instance = Object.create(metatype.prototype);\n      yield _this2.loadInstance(wrapper, collection, moduleRef, contextId, inquirer || wrapper);\n    })();\n  }\n\n  loadController(wrapper, moduleRef, contextId = constants_2.STATIC_CONTEXT) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const controllers = moduleRef.controllers;\n      yield _this3.loadInstance(wrapper, controllers, moduleRef, contextId, wrapper);\n      yield _this3.loadEnhancersPerContext(wrapper, contextId, wrapper);\n    })();\n  }\n\n  loadInjectable(wrapper, moduleRef, contextId = constants_2.STATIC_CONTEXT, inquirer) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const injectables = moduleRef.injectables;\n      yield _this4.loadInstance(wrapper, injectables, moduleRef, contextId, inquirer);\n    })();\n  }\n\n  loadProvider(wrapper, moduleRef, contextId = constants_2.STATIC_CONTEXT, inquirer) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const providers = moduleRef.providers;\n      yield _this5.loadInstance(wrapper, providers, moduleRef, contextId, inquirer);\n      yield _this5.loadEnhancersPerContext(wrapper, contextId, wrapper);\n    })();\n  }\n\n  applyDoneHook(wrapper) {\n    let done;\n    wrapper.donePromise = new Promise((resolve, reject) => {\n      done = resolve;\n    });\n    wrapper.isPending = true;\n    return done;\n  }\n\n  resolveConstructorParams(wrapper, moduleRef, inject, callback, contextId = constants_2.STATIC_CONTEXT, inquirer, parentInquirer) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const inquirerId = _this6.getInquirerId(inquirer);\n\n      const metadata = wrapper.getCtorMetadata();\n\n      if (metadata && contextId !== constants_2.STATIC_CONTEXT) {\n        const deps = yield _this6.loadCtorMetadata(metadata, contextId, inquirer, parentInquirer);\n        return callback(deps);\n      }\n\n      const dependencies = shared_utils_1.isNil(inject) ? _this6.reflectConstructorParams(wrapper.metatype) : inject;\n      const optionalDependenciesIds = shared_utils_1.isNil(inject) ? _this6.reflectOptionalParams(wrapper.metatype) : [];\n      let isResolved = true;\n\n      const resolveParam = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (param, index) {\n          try {\n            if (_this6.isInquirer(param, parentInquirer)) {\n              return parentInquirer && parentInquirer.instance;\n            }\n\n            const paramWrapper = yield _this6.resolveSingleParam(wrapper, param, {\n              index,\n              dependencies\n            }, moduleRef, contextId, inquirer, index);\n            const instanceHost = paramWrapper.getInstanceByContextId(contextId, inquirerId);\n\n            if (!instanceHost.isResolved && !paramWrapper.forwardRef) {\n              isResolved = false;\n            }\n\n            return instanceHost === null || instanceHost === void 0 ? void 0 : instanceHost.instance;\n          } catch (err) {\n            const isOptional = optionalDependenciesIds.includes(index);\n\n            if (!isOptional) {\n              throw err;\n            }\n\n            return undefined;\n          }\n        });\n\n        return function resolveParam(_x2, _x3) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n\n      const instances = yield Promise.all(dependencies.map(resolveParam));\n      isResolved && (yield callback(instances));\n    })();\n  }\n\n  reflectConstructorParams(type) {\n    const paramtypes = Reflect.getMetadata(constants_1.PARAMTYPES_METADATA, type) || [];\n    const selfParams = this.reflectSelfParams(type);\n    selfParams.forEach(({\n      index,\n      param\n    }) => paramtypes[index] = param);\n    return paramtypes;\n  }\n\n  reflectOptionalParams(type) {\n    return Reflect.getMetadata(constants_1.OPTIONAL_DEPS_METADATA, type) || [];\n  }\n\n  reflectSelfParams(type) {\n    return Reflect.getMetadata(constants_1.SELF_DECLARED_DEPS_METADATA, type) || [];\n  }\n\n  resolveSingleParam(wrapper, param, dependencyContext, moduleRef, contextId = constants_2.STATIC_CONTEXT, inquirer, keyOrIndex) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      if (shared_utils_1.isUndefined(param)) {\n        throw new undefined_dependency_exception_1.UndefinedDependencyException(wrapper.name, dependencyContext, moduleRef);\n      }\n\n      const token = _this7.resolveParamToken(wrapper, param);\n\n      return _this7.resolveComponentInstance(moduleRef, shared_utils_1.isFunction(token) ? token.name : token, dependencyContext, wrapper, contextId, inquirer, keyOrIndex);\n    })();\n  }\n\n  resolveParamToken(wrapper, param) {\n    if (!param.forwardRef) {\n      return param;\n    }\n\n    wrapper.forwardRef = true;\n    return param.forwardRef();\n  }\n\n  resolveComponentInstance(moduleRef, name, dependencyContext, wrapper, contextId = constants_2.STATIC_CONTEXT, inquirer, keyOrIndex) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const providers = moduleRef.providers;\n      const instanceWrapper = yield _this8.lookupComponent(providers, moduleRef, Object.assign(Object.assign({}, dependencyContext), {\n        name\n      }), wrapper, contextId, inquirer, keyOrIndex);\n      return _this8.resolveComponentHost(moduleRef, instanceWrapper, contextId, inquirer);\n    })();\n  }\n\n  resolveComponentHost(moduleRef, instanceWrapper, contextId = constants_2.STATIC_CONTEXT, inquirer) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      const inquirerId = _this9.getInquirerId(inquirer);\n\n      const instanceHost = instanceWrapper.getInstanceByContextId(contextId, inquirerId);\n\n      if (!instanceHost.isResolved && !instanceWrapper.forwardRef) {\n        yield _this9.loadProvider(instanceWrapper, moduleRef, contextId, inquirer);\n      } else if (!instanceHost.isResolved && instanceWrapper.forwardRef && (contextId !== constants_2.STATIC_CONTEXT || !!inquirerId)) {\n        /**\n         * When circular dependency has been detected between\n         * either request/transient providers, we have to asynchronously\n         * resolve instance host for a specific contextId or inquirer, to ensure\n         * that eventual lazily created instance will be merged with the prototype\n         * instantiated beforehand.\n         */\n        instanceHost.donePromise && instanceHost.donePromise.then(() => _this9.loadProvider(instanceWrapper, moduleRef, contextId, inquirer));\n      }\n\n      if (instanceWrapper.async) {\n        const host = instanceWrapper.getInstanceByContextId(contextId, inquirerId);\n        host.instance = yield host.instance;\n        instanceWrapper.setInstanceByContextId(contextId, host, inquirerId);\n      }\n\n      return instanceWrapper;\n    })();\n  }\n\n  lookupComponent(providers, moduleRef, dependencyContext, wrapper, contextId = constants_2.STATIC_CONTEXT, inquirer, keyOrIndex) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        name\n      } = dependencyContext;\n\n      if (wrapper && wrapper.name === name) {\n        throw new unknown_dependencies_exception_1.UnknownDependenciesException(wrapper.name, dependencyContext, moduleRef);\n      }\n\n      if (providers.has(name)) {\n        const instanceWrapper = providers.get(name);\n\n        _this10.addDependencyMetadata(keyOrIndex, wrapper, instanceWrapper);\n\n        return instanceWrapper;\n      }\n\n      return _this10.lookupComponentInParentModules(dependencyContext, moduleRef, wrapper, contextId, inquirer, keyOrIndex);\n    })();\n  }\n\n  lookupComponentInParentModules(dependencyContext, moduleRef, wrapper, contextId = constants_2.STATIC_CONTEXT, inquirer, keyOrIndex) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      const instanceWrapper = yield _this11.lookupComponentInImports(moduleRef, dependencyContext.name, wrapper, [], contextId, inquirer, keyOrIndex);\n\n      if (shared_utils_1.isNil(instanceWrapper)) {\n        throw new unknown_dependencies_exception_1.UnknownDependenciesException(wrapper.name, dependencyContext, moduleRef);\n      }\n\n      return instanceWrapper;\n    })();\n  }\n\n  lookupComponentInImports(moduleRef, name, wrapper, moduleRegistry = [], contextId = constants_2.STATIC_CONTEXT, inquirer, keyOrIndex, isTraversing) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      let instanceWrapperRef = null;\n      const imports = moduleRef.imports || new Set();\n\n      const identity = item => item;\n\n      let children = [...imports.values()].filter(identity);\n\n      if (isTraversing) {\n        const contextModuleExports = moduleRef.exports;\n        children = children.filter(child => contextModuleExports.has(child.metatype && child.metatype.name));\n      }\n\n      for (const relatedModule of children) {\n        if (moduleRegistry.includes(relatedModule.id)) {\n          continue;\n        }\n\n        moduleRegistry.push(relatedModule.id);\n        const {\n          providers,\n          exports\n        } = relatedModule;\n\n        if (!exports.has(name) || !providers.has(name)) {\n          const instanceRef = yield _this12.lookupComponentInImports(relatedModule, name, wrapper, moduleRegistry, contextId, inquirer, keyOrIndex, true);\n\n          if (instanceRef) {\n            _this12.addDependencyMetadata(keyOrIndex, wrapper, instanceRef);\n\n            return instanceRef;\n          }\n\n          continue;\n        }\n\n        instanceWrapperRef = providers.get(name);\n\n        _this12.addDependencyMetadata(keyOrIndex, wrapper, instanceWrapperRef);\n\n        const inquirerId = _this12.getInquirerId(inquirer);\n\n        const instanceHost = instanceWrapperRef.getInstanceByContextId(contextId, inquirerId);\n\n        if (!instanceHost.isResolved && !instanceWrapperRef.forwardRef) {\n          yield _this12.loadProvider(instanceWrapperRef, relatedModule, contextId, wrapper);\n          break;\n        }\n      }\n\n      return instanceWrapperRef;\n    })();\n  }\n\n  resolveProperties(wrapper, moduleRef, inject, contextId = constants_2.STATIC_CONTEXT, inquirer, parentInquirer) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!shared_utils_1.isNil(inject)) {\n        return [];\n      }\n\n      const metadata = wrapper.getPropertiesMetadata();\n\n      if (metadata && contextId !== constants_2.STATIC_CONTEXT) {\n        return _this13.loadPropertiesMetadata(metadata, contextId, inquirer);\n      }\n\n      const properties = _this13.reflectProperties(wrapper.metatype);\n\n      const instances = yield Promise.all(properties.map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (item) {\n          try {\n            const dependencyContext = {\n              key: item.key,\n              name: item.name\n            };\n\n            if (_this13.isInquirer(item.name, parentInquirer)) {\n              return parentInquirer && parentInquirer.instance;\n            }\n\n            const paramWrapper = yield _this13.resolveSingleParam(wrapper, item.name, dependencyContext, moduleRef, contextId, inquirer, item.key);\n\n            if (!paramWrapper) {\n              return undefined;\n            }\n\n            const inquirerId = _this13.getInquirerId(inquirer);\n\n            const instanceHost = paramWrapper.getInstanceByContextId(contextId, inquirerId);\n            return instanceHost.instance;\n          } catch (err) {\n            if (!item.isOptional) {\n              throw err;\n            }\n\n            return undefined;\n          }\n        });\n\n        return function (_x4) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n      return properties.map((item, index) => Object.assign(Object.assign({}, item), {\n        instance: instances[index]\n      }));\n    })();\n  }\n\n  reflectProperties(type) {\n    const properties = Reflect.getMetadata(constants_1.PROPERTY_DEPS_METADATA, type) || [];\n    const optionalKeys = Reflect.getMetadata(constants_1.OPTIONAL_PROPERTY_DEPS_METADATA, type) || [];\n    return properties.map(item => Object.assign(Object.assign({}, item), {\n      name: item.type,\n      isOptional: optionalKeys.includes(item.key)\n    }));\n  }\n\n  applyProperties(instance, properties) {\n    if (!shared_utils_1.isObject(instance)) {\n      return undefined;\n    }\n\n    iterare_1.iterate(properties).filter(item => !shared_utils_1.isNil(item.instance)).forEach(item => instance[item.key] = item.instance);\n  }\n\n  instantiateClass(instances, wrapper, targetMetatype, contextId = constants_2.STATIC_CONTEXT, inquirer) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        metatype,\n        inject\n      } = wrapper;\n\n      const inquirerId = _this14.getInquirerId(inquirer);\n\n      const instanceHost = targetMetatype.getInstanceByContextId(contextId, inquirerId);\n      const isStatic = wrapper.isStatic(contextId, inquirer);\n      const isInRequestScope = wrapper.isInRequestScope(contextId, inquirer);\n      const isLazyTransient = wrapper.isLazyTransient(contextId, inquirer);\n      const isExplicitlyRequested = wrapper.isExplicitlyRequested(contextId, inquirer);\n      const isInContext = isStatic || isInRequestScope || isLazyTransient || isExplicitlyRequested;\n\n      if (shared_utils_1.isNil(inject) && isInContext) {\n        instanceHost.instance = wrapper.forwardRef ? Object.assign(instanceHost.instance, new metatype(...instances)) : new metatype(...instances);\n      } else if (isInContext) {\n        const factoryReturnValue = targetMetatype.metatype(...instances);\n        instanceHost.instance = yield factoryReturnValue;\n      }\n\n      instanceHost.isResolved = true;\n      return instanceHost.instance;\n    })();\n  }\n\n  loadPerContext(instance, moduleRef, collection, ctx, wrapper) {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!wrapper) {\n        const providerCtor = instance.constructor;\n        const injectionToken = providerCtor && providerCtor.name || providerCtor;\n        wrapper = collection.get(injectionToken);\n      }\n\n      yield _this15.loadInstance(wrapper, collection, moduleRef, ctx, wrapper);\n      yield _this15.loadEnhancersPerContext(wrapper, ctx, wrapper);\n      const host = wrapper.getInstanceByContextId(ctx, wrapper.id);\n      return host && host.instance;\n    })();\n  }\n\n  loadEnhancersPerContext(wrapper, ctx, inquirer) {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      const enhancers = wrapper.getEnhancersMetadata() || [];\n\n      const loadEnhancer = item => {\n        const hostModule = item.host;\n        return _this16.loadInstance(item, hostModule.injectables, hostModule, ctx, inquirer);\n      };\n\n      yield Promise.all(enhancers.map(loadEnhancer));\n    })();\n  }\n\n  loadCtorMetadata(metadata, contextId, inquirer, parentInquirer) {\n    var _this17 = this;\n\n    return _asyncToGenerator(function* () {\n      const hosts = yield Promise.all(metadata.map( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (item) {\n          return _this17.resolveScopedComponentHost(item, contextId, inquirer, parentInquirer);\n        });\n\n        return function (_x5) {\n          return _ref4.apply(this, arguments);\n        };\n      }()));\n\n      const inquirerId = _this17.getInquirerId(inquirer);\n\n      return hosts.map(item => item.getInstanceByContextId(contextId, inquirerId).instance);\n    })();\n  }\n\n  loadPropertiesMetadata(metadata, contextId, inquirer) {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      const dependenciesHosts = yield Promise.all(metadata.map( /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator(function* ({\n          wrapper: item,\n          key\n        }) {\n          return {\n            key,\n            host: yield _this18.resolveComponentHost(item.host, item, contextId, inquirer)\n          };\n        });\n\n        return function (_x6) {\n          return _ref5.apply(this, arguments);\n        };\n      }()));\n\n      const inquirerId = _this18.getInquirerId(inquirer);\n\n      return dependenciesHosts.map(({\n        key,\n        host\n      }) => ({\n        key,\n        name: key,\n        instance: host.getInstanceByContextId(contextId, inquirerId).instance\n      }));\n    })();\n  }\n\n  getInquirerId(inquirer) {\n    return inquirer && inquirer.id;\n  }\n\n  resolveScopedComponentHost(item, contextId, inquirer, parentInquirer) {\n    return this.isInquirerRequest(item, parentInquirer) ? parentInquirer : this.resolveComponentHost(item.host, item, contextId, inquirer);\n  }\n\n  isInquirerRequest(item, parentInquirer) {\n    return item.isTransient && item.name === inquirer_1.INQUIRER && parentInquirer;\n  }\n\n  isInquirer(param, parentInquirer) {\n    return param === inquirer_1.INQUIRER && parentInquirer;\n  }\n\n  addDependencyMetadata(keyOrIndex, hostWrapper, instanceWrapper) {\n    shared_utils_1.isString(keyOrIndex) ? hostWrapper.addPropertiesMetadata(keyOrIndex, instanceWrapper) : hostWrapper.addCtorMetadata(keyOrIndex, instanceWrapper);\n  }\n\n}\n\nexports.Injector = Injector;","map":null,"metadata":{},"sourceType":"script"}
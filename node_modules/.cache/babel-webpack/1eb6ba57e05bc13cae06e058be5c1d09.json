{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/alessioricci/projects/udemy/udemy-app/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RouterExplorer = void 0;\n\nconst constants_1 = require(\"@nestjs/common/constants\");\n\nconst exceptions_1 = require(\"@nestjs/common/exceptions\");\n\nconst logger_service_1 = require(\"@nestjs/common/services/logger.service\");\n\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\n\nconst pathToRegexp = require(\"path-to-regexp\");\n\nconst unknown_request_mapping_exception_1 = require(\"../errors/exceptions/unknown-request-mapping.exception\");\n\nconst guards_consumer_1 = require(\"../guards/guards-consumer\");\n\nconst guards_context_creator_1 = require(\"../guards/guards-context-creator\");\n\nconst context_id_factory_1 = require(\"../helpers/context-id-factory\");\n\nconst execution_context_host_1 = require(\"../helpers/execution-context-host\");\n\nconst messages_1 = require(\"../helpers/messages\");\n\nconst router_method_factory_1 = require(\"../helpers/router-method-factory\");\n\nconst constants_2 = require(\"../injector/constants\");\n\nconst interceptors_consumer_1 = require(\"../interceptors/interceptors-consumer\");\n\nconst interceptors_context_creator_1 = require(\"../interceptors/interceptors-context-creator\");\n\nconst pipes_consumer_1 = require(\"../pipes/pipes-consumer\");\n\nconst pipes_context_creator_1 = require(\"../pipes/pipes-context-creator\");\n\nconst request_constants_1 = require(\"./request/request-constants\");\n\nconst route_params_factory_1 = require(\"./route-params-factory\");\n\nconst router_execution_context_1 = require(\"./router-execution-context\");\n\nclass RouterExplorer {\n  constructor(metadataScanner, container, injector, routerProxy, exceptionsFilter, config) {\n    this.metadataScanner = metadataScanner;\n    this.container = container;\n    this.injector = injector;\n    this.routerProxy = routerProxy;\n    this.exceptionsFilter = exceptionsFilter;\n    this.routerMethodFactory = new router_method_factory_1.RouterMethodFactory();\n    this.logger = new logger_service_1.Logger(RouterExplorer.name, true);\n    this.exceptionFiltersCache = new WeakMap();\n    this.executionContextCreator = new router_execution_context_1.RouterExecutionContext(new route_params_factory_1.RouteParamsFactory(), new pipes_context_creator_1.PipesContextCreator(container, config), new pipes_consumer_1.PipesConsumer(), new guards_context_creator_1.GuardsContextCreator(container, config), new guards_consumer_1.GuardsConsumer(), new interceptors_context_creator_1.InterceptorsContextCreator(container, config), new interceptors_consumer_1.InterceptorsConsumer(), container.getHttpAdapterRef());\n  }\n\n  explore(instanceWrapper, module, applicationRef, basePath, host) {\n    const {\n      instance\n    } = instanceWrapper;\n    const routerPaths = this.scanForPaths(instance);\n    this.applyPathsToRouterProxy(applicationRef, routerPaths, instanceWrapper, module, basePath, host);\n  }\n\n  extractRouterPath(metatype, prefix = '') {\n    let path = Reflect.getMetadata(constants_1.PATH_METADATA, metatype);\n\n    if (shared_utils_1.isUndefined(path)) {\n      throw new unknown_request_mapping_exception_1.UnknownRequestMappingException();\n    }\n\n    if (Array.isArray(path)) {\n      path = path.map(p => prefix + shared_utils_1.addLeadingSlash(p));\n    } else {\n      path = [prefix + shared_utils_1.addLeadingSlash(path)];\n    }\n\n    return path.map(p => shared_utils_1.addLeadingSlash(p));\n  }\n\n  scanForPaths(instance, prototype) {\n    const instancePrototype = shared_utils_1.isUndefined(prototype) ? Object.getPrototypeOf(instance) : prototype;\n    return this.metadataScanner.scanFromPrototype(instance, instancePrototype, method => this.exploreMethodMetadata(instance, instancePrototype, method));\n  }\n\n  exploreMethodMetadata(instance, prototype, methodName) {\n    const instanceCallback = instance[methodName];\n    const prototypeCallback = prototype[methodName];\n    const routePath = Reflect.getMetadata(constants_1.PATH_METADATA, prototypeCallback);\n\n    if (shared_utils_1.isUndefined(routePath)) {\n      return null;\n    }\n\n    const requestMethod = Reflect.getMetadata(constants_1.METHOD_METADATA, prototypeCallback);\n    const path = shared_utils_1.isString(routePath) ? [shared_utils_1.addLeadingSlash(routePath)] : routePath.map(p => shared_utils_1.addLeadingSlash(p));\n    return {\n      path,\n      requestMethod,\n      targetCallback: instanceCallback,\n      methodName\n    };\n  }\n\n  applyPathsToRouterProxy(router, routePaths, instanceWrapper, moduleKey, basePath, host) {\n    (routePaths || []).forEach(pathProperties => {\n      const {\n        path,\n        requestMethod\n      } = pathProperties;\n      this.applyCallbackToRouter(router, pathProperties, instanceWrapper, moduleKey, basePath, host);\n      path.forEach(item => {\n        const pathStr = this.stripEndSlash(basePath) + this.stripEndSlash(item);\n        this.logger.log(messages_1.ROUTE_MAPPED_MESSAGE(pathStr, requestMethod));\n      });\n    });\n  }\n\n  stripEndSlash(str) {\n    return str[str.length - 1] === '/' ? str.slice(0, str.length - 1) : str;\n  }\n\n  applyCallbackToRouter(router, pathProperties, instanceWrapper, moduleKey, basePath, host) {\n    const {\n      path: paths,\n      requestMethod,\n      targetCallback,\n      methodName\n    } = pathProperties;\n    const {\n      instance\n    } = instanceWrapper;\n    const routerMethod = this.routerMethodFactory.get(router, requestMethod).bind(router);\n    const isRequestScoped = !instanceWrapper.isDependencyTreeStatic();\n    const proxy = isRequestScoped ? this.createRequestScopedHandler(instanceWrapper, requestMethod, this.container.getModuleByKey(moduleKey), moduleKey, methodName) : this.createCallbackProxy(instance, targetCallback, methodName, moduleKey, requestMethod);\n    const hostHandler = this.applyHostFilter(host, proxy);\n    paths.forEach(path => {\n      const fullPath = this.stripEndSlash(basePath) + path;\n      routerMethod(this.stripEndSlash(fullPath) || '/', hostHandler);\n    });\n  }\n\n  applyHostFilter(host, handler) {\n    if (!host) {\n      return handler;\n    }\n\n    const httpAdapterRef = this.container.getHttpAdapterRef();\n    const hosts = Array.isArray(host) ? host : [host];\n    const hostRegExps = hosts.map(host => {\n      const keys = [];\n      const regexp = pathToRegexp(host, keys);\n      return {\n        regexp,\n        keys\n      };\n    });\n    const unsupportedFilteringErrorMessage = Array.isArray(host) ? `HTTP adapter does not support filtering on hosts: [\"${host.join('\", \"')}\"]` : `HTTP adapter does not support filtering on host: \"${host}\"`;\n    return (req, res, next) => {\n      req.hosts = {};\n      const hostname = httpAdapterRef.getRequestHostname(req) || '';\n\n      for (const exp of hostRegExps) {\n        const match = hostname.match(exp.regexp);\n\n        if (match) {\n          exp.keys.forEach((key, i) => req.hosts[key.name] = match[i + 1]);\n          return handler(req, res, next);\n        }\n      }\n\n      if (!next) {\n        throw new exceptions_1.InternalServerErrorException(unsupportedFilteringErrorMessage);\n      }\n\n      return next();\n    };\n  }\n\n  createCallbackProxy(instance, callback, methodName, moduleRef, requestMethod, contextId = constants_2.STATIC_CONTEXT, inquirerId) {\n    const executionContext = this.executionContextCreator.create(instance, callback, methodName, moduleRef, requestMethod, contextId, inquirerId);\n    const exceptionFilter = this.exceptionsFilter.create(instance, callback, moduleRef, contextId, inquirerId);\n    return this.routerProxy.createProxy(executionContext, exceptionFilter);\n  }\n\n  createRequestScopedHandler(instanceWrapper, requestMethod, moduleRef, moduleKey, methodName) {\n    var _this = this;\n\n    const {\n      instance\n    } = instanceWrapper;\n    const collection = moduleRef.controllers;\n    return /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (req, res, next) {\n        try {\n          const contextId = _this.getContextId(req);\n\n          const contextInstance = yield _this.injector.loadPerContext(instance, moduleRef, collection, contextId);\n          yield _this.createCallbackProxy(contextInstance, contextInstance[methodName], methodName, moduleKey, requestMethod, contextId, instanceWrapper.id)(req, res, next);\n        } catch (err) {\n          let exceptionFilter = _this.exceptionFiltersCache.get(instance[methodName]);\n\n          if (!exceptionFilter) {\n            exceptionFilter = _this.exceptionsFilter.create(instance, instance[methodName], moduleKey);\n\n            _this.exceptionFiltersCache.set(instance[methodName], exceptionFilter);\n          }\n\n          const host = new execution_context_host_1.ExecutionContextHost([req, res, next]);\n          exceptionFilter.next(err, host);\n        }\n      });\n\n      return function (_x, _x2, _x3) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n  }\n\n  getContextId(request) {\n    const contextId = context_id_factory_1.ContextIdFactory.getByRequest(request);\n\n    if (!request[request_constants_1.REQUEST_CONTEXT_ID]) {\n      Object.defineProperty(request, request_constants_1.REQUEST_CONTEXT_ID, {\n        value: contextId,\n        enumerable: false,\n        writable: false,\n        configurable: false\n      });\n      this.container.registerRequestProvider(request, contextId);\n    }\n\n    return contextId;\n  }\n\n}\n\nexports.RouterExplorer = RouterExplorer;","map":null,"metadata":{},"sourceType":"script"}
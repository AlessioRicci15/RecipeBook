{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/alessioricci/projects/udemy/udemy-app/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Module = void 0;\n\nconst random_string_generator_util_1 = require(\"@nestjs/common/utils/random-string-generator.util\");\n\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\n\nconst iterare_1 = require(\"iterare\");\n\nconst application_config_1 = require(\"../application-config\");\n\nconst invalid_class_exception_1 = require(\"../errors/exceptions/invalid-class.exception\");\n\nconst runtime_exception_1 = require(\"../errors/exceptions/runtime.exception\");\n\nconst unknown_export_exception_1 = require(\"../errors/exceptions/unknown-export.exception\");\n\nconst helpers_1 = require(\"../helpers\");\n\nconst get_class_scope_1 = require(\"../helpers/get-class-scope\");\n\nconst constants_1 = require(\"./constants\");\n\nconst instance_wrapper_1 = require(\"./instance-wrapper\");\n\nconst module_ref_1 = require(\"./module-ref\");\n\nclass Module {\n  constructor(_metatype, container) {\n    this._metatype = _metatype;\n    this.container = container;\n    this._imports = new Set();\n    this._providers = new Map();\n    this._injectables = new Map();\n    this._middlewares = new Map();\n    this._controllers = new Map();\n    this._exports = new Set();\n    this._distance = 0;\n    this.addCoreProviders();\n    this._id = random_string_generator_util_1.randomStringGenerator();\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  get providers() {\n    return this._providers;\n  }\n\n  get middlewares() {\n    return this._middlewares;\n  }\n\n  get imports() {\n    return this._imports;\n  }\n  /**\n   * Left for backward-compatibility reasons\n   */\n\n\n  get relatedModules() {\n    return this._imports;\n  }\n  /**\n   * Left for backward-compatibility reasons\n   */\n\n\n  get components() {\n    return this._providers;\n  }\n  /**\n   * Left for backward-compatibility reasons\n   */\n\n\n  get routes() {\n    return this._controllers;\n  }\n\n  get injectables() {\n    return this._injectables;\n  }\n\n  get controllers() {\n    return this._controllers;\n  }\n\n  get exports() {\n    return this._exports;\n  }\n\n  get instance() {\n    if (!this._providers.has(this._metatype.name)) {\n      throw new runtime_exception_1.RuntimeException();\n    }\n\n    const module = this._providers.get(this._metatype.name);\n\n    return module.instance;\n  }\n\n  get metatype() {\n    return this._metatype;\n  }\n\n  get distance() {\n    return this._distance;\n  }\n\n  set distance(value) {\n    this._distance = value;\n  }\n\n  addCoreProviders() {\n    this.addModuleAsProvider();\n    this.addModuleRef();\n    this.addApplicationConfig();\n  }\n\n  addModuleRef() {\n    const moduleRef = this.createModuleReferenceType();\n\n    this._providers.set(module_ref_1.ModuleRef.name, new instance_wrapper_1.InstanceWrapper({\n      name: module_ref_1.ModuleRef.name,\n      metatype: module_ref_1.ModuleRef,\n      isResolved: true,\n      instance: new moduleRef(),\n      host: this\n    }));\n  }\n\n  addModuleAsProvider() {\n    this._providers.set(this._metatype.name, new instance_wrapper_1.InstanceWrapper({\n      name: this._metatype.name,\n      metatype: this._metatype,\n      isResolved: false,\n      instance: null,\n      host: this\n    }));\n  }\n\n  addApplicationConfig() {\n    this._providers.set(application_config_1.ApplicationConfig.name, new instance_wrapper_1.InstanceWrapper({\n      name: application_config_1.ApplicationConfig.name,\n      isResolved: true,\n      instance: this.container.applicationConfig,\n      host: this\n    }));\n  }\n\n  addInjectable(injectable, host) {\n    if (this.isCustomProvider(injectable)) {\n      return this.addCustomProvider(injectable, this._injectables);\n    }\n\n    let instanceWrapper = this.injectables.get(injectable.name);\n\n    if (!instanceWrapper) {\n      instanceWrapper = new instance_wrapper_1.InstanceWrapper({\n        name: injectable.name,\n        metatype: injectable,\n        instance: null,\n        isResolved: false,\n        scope: get_class_scope_1.getClassScope(injectable),\n        host: this\n      });\n\n      this._injectables.set(injectable.name, instanceWrapper);\n    }\n\n    if (host) {\n      const token = host && host.name;\n\n      const hostWrapper = this._controllers.get(host && host.name) || this._providers.get(token);\n\n      hostWrapper && hostWrapper.addEnhancerMetadata(instanceWrapper);\n    }\n  }\n\n  addProvider(provider) {\n    if (this.isCustomProvider(provider)) {\n      return this.addCustomProvider(provider, this._providers);\n    }\n\n    this._providers.set(provider.name, new instance_wrapper_1.InstanceWrapper({\n      name: provider.name,\n      metatype: provider,\n      instance: null,\n      isResolved: false,\n      scope: get_class_scope_1.getClassScope(provider),\n      host: this\n    }));\n\n    return provider.name;\n  }\n\n  isCustomProvider(provider) {\n    return !shared_utils_1.isNil(provider.provide);\n  }\n\n  addCustomProvider(provider, collection) {\n    const name = this.getProviderStaticToken(provider.provide);\n    provider = Object.assign(Object.assign({}, provider), {\n      name\n    });\n\n    if (this.isCustomClass(provider)) {\n      this.addCustomClass(provider, collection);\n    } else if (this.isCustomValue(provider)) {\n      this.addCustomValue(provider, collection);\n    } else if (this.isCustomFactory(provider)) {\n      this.addCustomFactory(provider, collection);\n    } else if (this.isCustomUseExisting(provider)) {\n      this.addCustomUseExisting(provider, collection);\n    }\n\n    return name;\n  }\n\n  isCustomClass(provider) {\n    return !shared_utils_1.isUndefined(provider.useClass);\n  }\n\n  isCustomValue(provider) {\n    return !shared_utils_1.isUndefined(provider.useValue);\n  }\n\n  isCustomFactory(provider) {\n    return !shared_utils_1.isUndefined(provider.useFactory);\n  }\n\n  isCustomUseExisting(provider) {\n    return !shared_utils_1.isUndefined(provider.useExisting);\n  }\n\n  isDynamicModule(exported) {\n    return exported && exported.module;\n  }\n\n  addCustomClass(provider, collection) {\n    const {\n      name,\n      useClass\n    } = provider;\n    let {\n      scope\n    } = provider;\n\n    if (shared_utils_1.isUndefined(scope)) {\n      scope = get_class_scope_1.getClassScope(useClass);\n    }\n\n    collection.set(name, new instance_wrapper_1.InstanceWrapper({\n      name,\n      metatype: useClass,\n      instance: null,\n      isResolved: false,\n      scope,\n      host: this\n    }));\n  }\n\n  addCustomValue(provider, collection) {\n    const {\n      name,\n      useValue: value\n    } = provider;\n    collection.set(name, new instance_wrapper_1.InstanceWrapper({\n      name,\n      metatype: null,\n      instance: value,\n      isResolved: true,\n      async: value instanceof Promise,\n      host: this\n    }));\n  }\n\n  addCustomFactory(provider, collection) {\n    const {\n      name,\n      useFactory: factory,\n      inject,\n      scope\n    } = provider;\n    collection.set(name, new instance_wrapper_1.InstanceWrapper({\n      name,\n      metatype: factory,\n      instance: null,\n      isResolved: false,\n      inject: inject || [],\n      scope,\n      host: this\n    }));\n  }\n\n  addCustomUseExisting(provider, collection) {\n    const {\n      name,\n      useExisting\n    } = provider;\n    collection.set(name, new instance_wrapper_1.InstanceWrapper({\n      name,\n      metatype: instance => instance,\n      instance: null,\n      isResolved: false,\n      inject: [useExisting],\n      host: this,\n      isAlias: true\n    }));\n  }\n\n  addExportedProvider(provider) {\n    const addExportedUnit = token => this._exports.add(this.validateExportedProvider(token));\n\n    if (this.isCustomProvider(provider)) {\n      return this.addCustomExportedProvider(provider);\n    } else if (shared_utils_1.isString(provider) || shared_utils_1.isSymbol(provider)) {\n      return addExportedUnit(provider);\n    } else if (this.isDynamicModule(provider)) {\n      const {\n        module\n      } = provider;\n      return addExportedUnit(module.name);\n    }\n\n    addExportedUnit(provider.name);\n  }\n\n  addCustomExportedProvider(provider) {\n    const provide = provider.provide;\n\n    if (shared_utils_1.isString(provide) || shared_utils_1.isSymbol(provide)) {\n      return this._exports.add(this.validateExportedProvider(provide));\n    }\n\n    this._exports.add(this.validateExportedProvider(provide.name));\n  }\n\n  validateExportedProvider(token) {\n    if (this._providers.has(token)) {\n      return token;\n    }\n\n    const importsArray = [...this._imports.values()];\n    const importsNames = iterare_1.iterate(importsArray).filter(item => !!item).map(({\n      metatype\n    }) => metatype).filter(metatype => !!metatype).map(({\n      name\n    }) => name).toArray();\n\n    if (!importsNames.includes(token)) {\n      const {\n        name\n      } = this.metatype;\n      throw new unknown_export_exception_1.UnknownExportException(token, name);\n    }\n\n    return token;\n  }\n\n  addController(controller) {\n    this._controllers.set(controller.name, new instance_wrapper_1.InstanceWrapper({\n      name: controller.name,\n      metatype: controller,\n      instance: null,\n      isResolved: false,\n      scope: get_class_scope_1.getClassScope(controller),\n      host: this\n    }));\n\n    this.assignControllerUniqueId(controller);\n  }\n\n  assignControllerUniqueId(controller) {\n    Object.defineProperty(controller, constants_1.CONTROLLER_ID_KEY, {\n      enumerable: false,\n      writable: false,\n      configurable: true,\n      value: random_string_generator_util_1.randomStringGenerator()\n    });\n  }\n\n  addRelatedModule(module) {\n    this._imports.add(module);\n  }\n\n  replace(toReplace, options) {\n    if (options.isProvider && this.hasProvider(toReplace)) {\n      const name = this.getProviderStaticToken(toReplace);\n\n      const originalProvider = this._providers.get(name);\n\n      return originalProvider.mergeWith(Object.assign({\n        provide: toReplace\n      }, options));\n    } else if (!options.isProvider && this.hasInjectable(toReplace)) {\n      const name = this.getProviderStaticToken(toReplace);\n\n      const originalInjectable = this._injectables.get(name);\n\n      return originalInjectable.mergeWith(Object.assign({\n        provide: toReplace\n      }, options));\n    }\n  }\n\n  hasProvider(token) {\n    const name = this.getProviderStaticToken(token);\n    return this._providers.has(name);\n  }\n\n  hasInjectable(token) {\n    const name = this.getProviderStaticToken(token);\n    return this._injectables.has(name);\n  }\n\n  getProviderStaticToken(provider) {\n    return shared_utils_1.isFunction(provider) ? provider.name : provider;\n  }\n\n  getProviderByKey(name) {\n    return this._providers.get(name);\n  }\n\n  getNonAliasProviders() {\n    return [...this._providers].filter(([_, wrapper]) => !wrapper.isAlias);\n  }\n\n  createModuleReferenceType() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    return class extends module_ref_1.ModuleRef {\n      constructor() {\n        super(self.container);\n      }\n\n      get(typeOrToken, options = {\n        strict: true\n      }) {\n        return !(options && options.strict) ? this.find(typeOrToken) : this.find(typeOrToken, self);\n      }\n\n      resolve(typeOrToken, contextId = helpers_1.createContextId(), options = {\n        strict: true\n      }) {\n        return this.resolvePerContext(typeOrToken, self, contextId, options);\n      }\n\n      create(type) {\n        var _this = this;\n\n        return _asyncToGenerator(function* () {\n          if (!(type && shared_utils_1.isFunction(type) && type.prototype)) {\n            throw new invalid_class_exception_1.InvalidClassException(type);\n          }\n\n          return _this.instantiateClass(type, self);\n        })();\n      }\n\n    };\n  }\n\n}\n\nexports.Module = Module;","map":null,"metadata":{},"sourceType":"script"}
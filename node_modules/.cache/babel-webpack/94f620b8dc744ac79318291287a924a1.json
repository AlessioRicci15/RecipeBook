{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/alessioricci/projects/udemy/udemy-app/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DependenciesScanner = void 0;\n\nconst common_1 = require(\"@nestjs/common\");\n\nconst constants_1 = require(\"@nestjs/common/constants\");\n\nconst interfaces_1 = require(\"@nestjs/common/interfaces\");\n\nconst random_string_generator_util_1 = require(\"@nestjs/common/utils/random-string-generator.util\");\n\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\n\nconst iterare_1 = require(\"iterare\");\n\nconst application_config_1 = require(\"./application-config\");\n\nconst constants_2 = require(\"./constants\");\n\nconst circular_dependency_exception_1 = require(\"./errors/exceptions/circular-dependency.exception\");\n\nconst invalid_module_exception_1 = require(\"./errors/exceptions/invalid-module.exception\");\n\nconst undefined_module_exception_1 = require(\"./errors/exceptions/undefined-module.exception\");\n\nconst get_class_scope_1 = require(\"./helpers/get-class-scope\");\n\nclass DependenciesScanner {\n  constructor(container, metadataScanner, applicationConfig = new application_config_1.ApplicationConfig()) {\n    this.container = container;\n    this.metadataScanner = metadataScanner;\n    this.applicationConfig = applicationConfig;\n    this.applicationProvidersApplyMap = [];\n  }\n\n  scan(module) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this.registerCoreModule();\n      yield _this.scanForModules(module);\n      yield _this.scanModulesForDependencies();\n\n      _this.addScopedEnhancersMetadata();\n\n      _this.container.bindGlobalScope();\n    })();\n  }\n\n  scanForModules(moduleDefinition, scope = [], ctxRegistry = []) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const moduleInstance = yield _this2.insertModule(moduleDefinition, scope);\n      moduleDefinition = moduleDefinition instanceof Promise ? yield moduleDefinition : moduleDefinition;\n      ctxRegistry.push(moduleDefinition);\n\n      if (_this2.isForwardReference(moduleDefinition)) {\n        moduleDefinition = moduleDefinition.forwardRef();\n      }\n\n      const modules = !_this2.isDynamicModule(moduleDefinition) ? _this2.reflectMetadata(moduleDefinition, constants_1.MODULE_METADATA.IMPORTS) : [..._this2.reflectMetadata(moduleDefinition.module, constants_1.MODULE_METADATA.IMPORTS), ...(moduleDefinition.imports || [])];\n\n      for (const [index, innerModule] of modules.entries()) {\n        // In case of a circular dependency (ES module system), JavaScript will resolve the type to `undefined`.\n        if (innerModule === undefined) {\n          throw new undefined_module_exception_1.UndefinedModuleException(moduleDefinition, index, scope);\n        }\n\n        if (!innerModule) {\n          throw new invalid_module_exception_1.InvalidModuleException(moduleDefinition, index, scope);\n        }\n\n        if (ctxRegistry.includes(innerModule)) {\n          continue;\n        }\n\n        yield _this2.scanForModules(innerModule, [].concat(scope, moduleDefinition), ctxRegistry);\n      }\n\n      return moduleInstance;\n    })();\n  }\n\n  insertModule(module, scope) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (module && module.forwardRef) {\n        return _this3.container.addModule(module.forwardRef(), scope);\n      }\n\n      return _this3.container.addModule(module, scope);\n    })();\n  }\n\n  scanModulesForDependencies() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const modules = _this4.container.getModules();\n\n      for (const [token, {\n        metatype\n      }] of modules) {\n        yield _this4.reflectImports(metatype, token, metatype.name);\n\n        _this4.reflectProviders(metatype, token);\n\n        _this4.reflectControllers(metatype, token);\n\n        _this4.reflectExports(metatype, token);\n      }\n\n      _this4.calculateModulesDistance(modules);\n    })();\n  }\n\n  reflectImports(module, token, context) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const modules = [..._this5.reflectMetadata(module, constants_1.MODULE_METADATA.IMPORTS), ..._this5.container.getDynamicMetadataByToken(token, constants_1.MODULE_METADATA.IMPORTS)];\n\n      for (const related of modules) {\n        yield _this5.insertImport(related, token, context);\n      }\n    })();\n  }\n\n  reflectProviders(module, token) {\n    const providers = [...this.reflectMetadata(module, constants_1.MODULE_METADATA.PROVIDERS), ...this.container.getDynamicMetadataByToken(token, constants_1.MODULE_METADATA.PROVIDERS)];\n    providers.forEach(provider => {\n      this.insertProvider(provider, token);\n      this.reflectDynamicMetadata(provider, token);\n    });\n  }\n\n  reflectControllers(module, token) {\n    const controllers = [...this.reflectMetadata(module, constants_1.MODULE_METADATA.CONTROLLERS), ...this.container.getDynamicMetadataByToken(token, constants_1.MODULE_METADATA.CONTROLLERS)];\n    controllers.forEach(item => {\n      this.insertController(item, token);\n      this.reflectDynamicMetadata(item, token);\n    });\n  }\n\n  reflectDynamicMetadata(obj, token) {\n    if (!obj || !obj.prototype) {\n      return;\n    }\n\n    this.reflectInjectables(obj, token, constants_1.GUARDS_METADATA);\n    this.reflectInjectables(obj, token, constants_1.INTERCEPTORS_METADATA);\n    this.reflectInjectables(obj, token, constants_1.EXCEPTION_FILTERS_METADATA);\n    this.reflectInjectables(obj, token, constants_1.PIPES_METADATA);\n    this.reflectParamInjectables(obj, token, constants_1.ROUTE_ARGS_METADATA);\n  }\n\n  reflectExports(module, token) {\n    const exports = [...this.reflectMetadata(module, constants_1.MODULE_METADATA.EXPORTS), ...this.container.getDynamicMetadataByToken(token, constants_1.MODULE_METADATA.EXPORTS)];\n    exports.forEach(exportedProvider => this.insertExportedProvider(exportedProvider, token));\n  }\n\n  reflectInjectables(component, token, metadataKey) {\n    const controllerInjectables = this.reflectMetadata(component, metadataKey);\n    const methodsInjectables = this.metadataScanner.scanFromPrototype(null, component.prototype, this.reflectKeyMetadata.bind(this, component, metadataKey));\n    const flattenMethodsInjectables = this.flatten(methodsInjectables);\n    const combinedInjectables = [...controllerInjectables, ...flattenMethodsInjectables].filter(shared_utils_1.isFunction);\n    const injectables = Array.from(new Set(combinedInjectables));\n    injectables.forEach(injectable => this.insertInjectable(injectable, token, component));\n  }\n\n  reflectParamInjectables(component, token, metadataKey) {\n    const paramsMetadata = this.metadataScanner.scanFromPrototype(null, component.prototype, method => Reflect.getMetadata(metadataKey, component, method));\n    const paramsInjectables = this.flatten(paramsMetadata).map(param => common_1.flatten(Object.keys(param).map(k => param[k].pipes)).filter(shared_utils_1.isFunction));\n    common_1.flatten(paramsInjectables).forEach(injectable => this.insertInjectable(injectable, token, component));\n  }\n\n  reflectKeyMetadata(component, key, method) {\n    let prototype = component.prototype;\n\n    do {\n      const descriptor = Reflect.getOwnPropertyDescriptor(prototype, method);\n\n      if (!descriptor) {\n        continue;\n      }\n\n      return Reflect.getMetadata(key, descriptor.value);\n    } while ((prototype = Reflect.getPrototypeOf(prototype)) && prototype !== Object.prototype && prototype);\n\n    return undefined;\n  }\n\n  calculateModulesDistance(modules) {\n    return _asyncToGenerator(function* () {\n      const modulesGenerator = modules.values();\n      const rootModule = modulesGenerator.next().value;\n      const modulesStack = [rootModule];\n\n      const calculateDistance = (moduleRef, distance = 1) => {\n        if (modulesStack.includes(moduleRef)) {\n          return;\n        }\n\n        modulesStack.push(moduleRef);\n        const moduleImports = rootModule.relatedModules;\n        moduleImports.forEach(module => {\n          module.distance = distance;\n          calculateDistance(module, distance + 1);\n        });\n      };\n\n      calculateDistance(rootModule);\n    })();\n  }\n\n  insertImport(related, token, context) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      if (shared_utils_1.isUndefined(related)) {\n        throw new circular_dependency_exception_1.CircularDependencyException(context);\n      }\n\n      if (related && related.forwardRef) {\n        return _this6.container.addImport(related.forwardRef(), token);\n      }\n\n      yield _this6.container.addImport(related, token);\n    })();\n  }\n\n  isCustomProvider(provider) {\n    return provider && !shared_utils_1.isNil(provider.provide);\n  }\n\n  insertProvider(provider, token) {\n    const isCustomProvider = this.isCustomProvider(provider);\n\n    if (!isCustomProvider) {\n      return this.container.addProvider(provider, token);\n    }\n\n    const applyProvidersMap = this.getApplyProvidersMap();\n    const providersKeys = Object.keys(applyProvidersMap);\n    const type = provider.provide;\n\n    if (!providersKeys.includes(type)) {\n      return this.container.addProvider(provider, token);\n    }\n\n    const providerToken = `${type} (UUID: ${random_string_generator_util_1.randomStringGenerator()})`;\n    let scope = provider.scope;\n\n    if (shared_utils_1.isNil(scope) && provider.useClass) {\n      scope = get_class_scope_1.getClassScope(provider.useClass);\n    }\n\n    this.applicationProvidersApplyMap.push({\n      type,\n      moduleKey: token,\n      providerKey: providerToken,\n      scope\n    });\n    const newProvider = Object.assign(Object.assign({}, provider), {\n      provide: providerToken,\n      scope\n    });\n\n    if (this.isRequestOrTransient(newProvider.scope)) {\n      return this.container.addInjectable(newProvider, token);\n    }\n\n    this.container.addProvider(newProvider, token);\n  }\n\n  insertInjectable(injectable, token, host) {\n    this.container.addInjectable(injectable, token, host);\n  }\n\n  insertExportedProvider(exportedProvider, token) {\n    this.container.addExportedProvider(exportedProvider, token);\n  }\n\n  insertController(controller, token) {\n    this.container.addController(controller, token);\n  }\n\n  reflectMetadata(metatype, metadataKey) {\n    return Reflect.getMetadata(metadataKey, metatype) || [];\n  }\n\n  registerCoreModule() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const module = _this7.container.createCoreModule();\n\n      const instance = yield _this7.scanForModules(module);\n\n      _this7.container.registerCoreModuleRef(instance);\n    })();\n  }\n  /**\n   * Add either request or transient globally scoped enhancers\n   * to all controllers metadata storage\n   */\n\n\n  addScopedEnhancersMetadata() {\n    iterare_1.iterate(this.applicationProvidersApplyMap).filter(wrapper => this.isRequestOrTransient(wrapper.scope)).forEach(({\n      moduleKey,\n      providerKey\n    }) => {\n      const modulesContainer = this.container.getModules();\n      const {\n        injectables\n      } = modulesContainer.get(moduleKey);\n      const instanceWrapper = injectables.get(providerKey);\n      iterare_1.iterate(modulesContainer.values()).map(module => module.controllers.values()).flatten().forEach(controller => controller.addEnhancerMetadata(instanceWrapper));\n    });\n  }\n\n  applyApplicationProviders() {\n    const applyProvidersMap = this.getApplyProvidersMap();\n    const applyRequestProvidersMap = this.getApplyRequestProvidersMap();\n\n    const getInstanceWrapper = (moduleKey, providerKey, collectionKey) => {\n      const modules = this.container.getModules();\n      const collection = modules.get(moduleKey)[collectionKey];\n      return collection.get(providerKey);\n    }; // Add global enhancers to the application config\n\n\n    this.applicationProvidersApplyMap.forEach(({\n      moduleKey,\n      providerKey,\n      type,\n      scope\n    }) => {\n      let instanceWrapper;\n\n      if (this.isRequestOrTransient(scope)) {\n        instanceWrapper = getInstanceWrapper(moduleKey, providerKey, 'injectables');\n        return applyRequestProvidersMap[type](instanceWrapper);\n      }\n\n      instanceWrapper = getInstanceWrapper(moduleKey, providerKey, 'providers');\n      applyProvidersMap[type](instanceWrapper.instance);\n    });\n  }\n\n  getApplyProvidersMap() {\n    return {\n      [constants_2.APP_INTERCEPTOR]: interceptor => this.applicationConfig.addGlobalInterceptor(interceptor),\n      [constants_2.APP_PIPE]: pipe => this.applicationConfig.addGlobalPipe(pipe),\n      [constants_2.APP_GUARD]: guard => this.applicationConfig.addGlobalGuard(guard),\n      [constants_2.APP_FILTER]: filter => this.applicationConfig.addGlobalFilter(filter)\n    };\n  }\n\n  getApplyRequestProvidersMap() {\n    return {\n      [constants_2.APP_INTERCEPTOR]: interceptor => this.applicationConfig.addGlobalRequestInterceptor(interceptor),\n      [constants_2.APP_PIPE]: pipe => this.applicationConfig.addGlobalRequestPipe(pipe),\n      [constants_2.APP_GUARD]: guard => this.applicationConfig.addGlobalRequestGuard(guard),\n      [constants_2.APP_FILTER]: filter => this.applicationConfig.addGlobalRequestFilter(filter)\n    };\n  }\n\n  isDynamicModule(module) {\n    return module && !!module.module;\n  }\n\n  isForwardReference(module) {\n    return module && !!module.forwardRef;\n  }\n\n  flatten(arr) {\n    return arr.reduce((a, b) => a.concat(b), []);\n  }\n\n  isRequestOrTransient(scope) {\n    return scope === interfaces_1.Scope.REQUEST || scope === interfaces_1.Scope.TRANSIENT;\n  }\n\n}\n\nexports.DependenciesScanner = DependenciesScanner;","map":null,"metadata":{},"sourceType":"script"}